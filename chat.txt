### USER
I want to write a web app as a single HTML file using HTML, Javascript and CSS. The app will allow readers to select annotations on the syntax of Greek texts, and visualize the data in various ways. We'll develop it gradually. First I want to build a UI for loading and organizing the data to visualize.
  
Begin by letting the user choose a local file. To load the dataL, I want to use the `cex.js` library. Please include it like this:
  
  
```<script src="https://cdn.jsdelivr.net/gh/neelsmith/cex-lib/cex.js"></script>```
  
Then we'll use its `loadFromFile` function with one parameter, the user-selected file. This will return a `Promise<CEXParser>`. When we have a parser instance,
we'll use the `getDelimitedData` function three times to collect data about annotated sentences. We'll get annotation on sentences by calling `getDelimitedData("sentences")`, annotatoins on _verbal units_ with `getDelimitedData("verbal_units")` and annotations on _tokens_ with `getDelimitedData("tokens")` . Here's an example of how you could get the annotations on sentences:
  
```
const parser = new CEXParser();
parser.loadFromFile(filename)
    .then(p => {
        console.log('CEX data loaded from file!');
        console.log(p.getDelimitedData("sentences"));
    })
    .catch(error => console.error('Failed to load from file:', error));
  
```
  
  
`getDelimitedData` will return a string.
In the result for sentences, each line represents a delimited-text record for a sentence. Each sentence record has three pipe-delimited columns, `sentence`, `sequence` and `connector`. Use the values of the `sentence` column to create a list of identifiers for sentences in the text.
  
In the verbal units data, each line is a record for 1 verbal unit with 5 pipe-delimited columns: `vuid`, `syntactic_type`, `semantic_type`, `depth` and `sentence`.
  
In the tokens data, each line is a record for 1 token with 9 pipe-delimited columns, `urn`, `reference`, `tokentype`, `text`, `verbalunit`, `node1`, `node1relation`, `node2` and `node2relation`. For each verbal unit in this sentence, find all the tokens with a `verbalunit` column matching the verbal unit's `vuid` column.
  
  
The first part of the UI to build is a menu allowing the user to select a sentence identifier. Filter the list of sentences to include only those sentences which appear as a value in the `sentence` column of the verbal units data, and create a menu of these. Display the user's selection.
  
When the user chooses a sentence, find all the verbal units with the `sentence` value matching the user's selection of sentence. For each verbal unit, choose a pastel color that is easily distinguished from all other selected colors.
Create a list of the verbal units displaying them as follows highlight the value of `syntactic_type` using the unique color for that verbal unit, then in parentheses give the `semantic_type`, then show how many tokens it contains.

### ASSISTANT
Okay, let's build this step by step. This will be a single HTML file incorporating HTML for structure, CSS for basic styling, and JavaScript for the logic.

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Greek Syntax Annotations Viewer</title>
    <script src="https://cdn.jsdelivr.net/gh/neelsmith/cex-lib/cex.js"></script>
    <style>
        body {
            font-family: sans-serif;
            margin: 20px;
            background-color: #f4f4f4;
            color: #333;
        }
        .container {
            background-color: #fff;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 0 10px rgba(0,0,0,0.1);
        }
        h1, h2 {
            color: #555;
        }
        label {
            display: block;
            margin-top: 10px;
            margin-bottom: 5px;
            font-weight: bold;
        }
        select, input[type="file"] {
            padding: 8px;
            margin-bottom: 15px;
            border-radius: 4px;
            border: 1px solid #ccc;
            width: 100%;
            box-sizing: border-box;
        }
        #selectedSentenceDisplay {
            margin-top: 15px;
            padding: 10px;
            background-color: #e9e9e9;
            border-left: 5px solid #007bff;
            font-style: italic;
        }
        #verbalUnitsDisplay ul {
            list-style-type: none;
            padding: 0;
        }
        #verbalUnitsDisplay li {
            padding: 8px;
            border-bottom: 1px solid #eee;
            margin-bottom: 5px;
        }
        #verbalUnitsDisplay li:last-child {
            border-bottom: none;
        }
        .syntactic-type {
            padding: 2px 5px;
            border-radius: 3px;
            font-weight: bold;
            color: #fff; /* Text color will be white for better contrast with pastels */
        }
        .error {
            color: red;
            font-weight: bold;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Greek Syntax Data Loader</h1>

        <label for="fileInput">Choose a CEX file:</label>
        <input type="file" id="fileInput" accept=".cex">

        <div id="sentenceSection" style="display: none;">
            <label for="sentenceSelector">Select a Sentence:</label>
            <select id="sentenceSelector"></select>
            <div id="selectedSentenceDisplay"></div>
        </div>

        <div id="verbalUnitsSection" style="display: none;">
            <h2>Verbal Units in Selected Sentence:</h2>
            <div id="verbalUnitsDisplay">
                <ul></ul>
            </div>
        </div>
        
        <div id="statusMessages"></div>

    </div>

    <script>
        // Global storage for parsed data
        let parsedSentences = [];
        let parsedVerbalUnits = [];
        let parsedTokens = [];

        // Predefined pastel colors for highlighting
        const PASTEL_COLORS = [
            "#FFB3BA", // Light Pink
            "#FFDFBA", // Light Peach
            "#FFFFBA", // Light Yellow
            "#BAFFC9", // Light Mint
            "#BAE1FF", // Light Blue
            "#E0BBE4", // Light Lavender
            "#FFDAC1", // Light Apricot
            "#B5EAD7", // Light Aqua
            "#F9C7CF", // Light Rose
            "#C7CEEA"  // Light Periwinkle
        ];
        let colorIndex = 0;

        const fileInput = document.getElementById('fileInput');
        const sentenceSelector = document.getElementById('sentenceSelector');
        const selectedSentenceDisplay = document.getElementById('selectedSentenceDisplay');
        const verbalUnitsDisplayUl = document.querySelector('#verbalUnitsDisplay ul');
        const sentenceSection = document.getElementById('sentenceSection');
        const verbalUnitsSection = document.getElementById('verbalUnitsSection');
        const statusMessages = document.getElementById('statusMessages');

        fileInput.addEventListener('change', handleFileSelect);
        sentenceSelector.addEventListener('change', handleSentenceSelection);

        function displayError(message) {
            statusMessages.innerHTML = `<p class="error">${message}</p>`;
            console.error(message);
        }

        function displayStatus(message) {
            statusMessages.innerHTML = `<p>${message}</p>`;
            console.log(message);
        }

        function clearPreviousData() {
            parsedSentences = [];
            parsedVerbalUnits = [];
            parsedTokens = [];
            sentenceSelector.innerHTML = '<option value="">-- Load a file --</option>';
            selectedSentenceDisplay.textContent = '';
            verbalUnitsDisplayUl.innerHTML = '';
            sentenceSection.style.display = 'none';
            verbalUnitsSection.style.display = 'none';
            statusMessages.innerHTML = '';
            colorIndex = 0;
        }

        function handleFileSelect(event) {
            clearPreviousData();
            const file = event.target.files[0];
            if (!file) {
                displayError('No file selected.');
                return;
            }

            displayStatus(`Loading ${file.name}...`);
            const parser = new CEXParser();
            parser.loadFromFile(file)
                .then(p => {
                    displayStatus('CEX data loaded! Processing...');
                    
                    const sentencesStr = p.getDelimitedData("sentences");
                    const verbalUnitsStr = p.getDelimitedData("verbal_units");
                    const tokensStr = p.getDelimitedData("tokens");

                    if (!sentencesStr || !verbalUnitsStr || !tokensStr) {
                        displayError('One or more required data blocks (sentences, verbal_units, tokens) are missing or empty in the CEX file.');
                        return;
                    }

                    // Parse Sentences: sentence|sequence|connector
                    parsedSentences = sentencesStr.trim().split('\n')
                        .map(line => {
                            const parts = line.split('|');
                            return { id: parts[0], sequence: parts[1], connector: parts[2] };
                        })
                        .filter(s => s.id); // Ensure id is present

                    // Parse Verbal Units: vuid|syntactic_type|semantic_type|depth|sentence
                    parsedVerbalUnits = verbalUnitsStr.trim().split('\n')
                        .map(line => {
                            const parts = line.split('|');
                            return { 
                                vuid: parts[0], 
                                syntactic_type: parts[1], 
                                semantic_type: parts[2], 
                                depth: parts[3], 
                                sentence: parts[4] 
                            };
                        })
                        .filter(vu => vu.vuid && vu.sentence); // Ensure vuid and sentence are present

                    // Parse Tokens: urn|reference|tokentype|text|verbalunit|node1|node1relation|node2|node2relation
                    parsedTokens = tokensStr.trim().split('\n')
                        .map(line => {
                            const parts = line.split('|');
                            return {
                                urn: parts[0],
                                reference: parts[1],
                                tokentype: parts[2],
                                text: parts[3],
                                verbalunit: parts[4],
                                node1: parts[5],
                                node1relation: parts[6],
                                node2: parts[7],
                                node2relation: parts[8]
                            };
                        })
                        .filter(t => t.urn && t.verbalunit); // Ensure urn and verbalunit are present

                    if (parsedVerbalUnits.length === 0) {
                        displayError('No verbal units found in the data. Cannot proceed.');
                        return;
                    }

                    populateSentenceSelector();
                    sentenceSection.style.display = 'block';
                    displayStatus(`Successfully processed ${file.name}. Select a sentence.`);

                })
                .catch(error => {
                    displayError(`Failed to load or parse CEX file: ${error.message}`);
                    console.error('Detailed error:', error);
                });
        }

        function populateSentenceSelector() {
            sentenceSelector.innerHTML = '<option value="">-- Select a Sentence --</option>'; // Reset

            const sentenceIdsInVUs = new Set(parsedVerbalUnits.map(vu => vu.sentence));
            
            // Original sentence identifiers from the "sentences" block
            const allSentenceIdsFromSentencesBlock = new Set(parsedSentences.map(s => s.id));

            // Filter these by checking if they are present in verbal units
            const displayableSentenceIds = [...allSentenceIdsFromSentencesBlock].filter(id => sentenceIdsInVUs.has(id));
            
            // Sort them if they have a numeric component for better ordering
            displayableSentenceIds.sort((a, b) => {
                const numA = parseInt(a.match(/\d+$/)?.[0] || a);
                const numB = parseInt(b.match(/\d+$/)?.[0] || b);
                if (!isNaN(numA) && !isNaN(numB)) return numA - numB;
                return a.localeCompare(b);
            });


            if (displayableSentenceIds.length === 0) {
                sentenceSelector.innerHTML = '<option value="">-- No sentences with verbal units --</option>';
                displayError('No sentences found that have associated verbal units.');
                return;
            }

            displayableSentenceIds.forEach(sentenceId => {
                const option = document.createElement('option');
                option.value = sentenceId;
                option.textContent = sentenceId;
                sentenceSelector.appendChild(option);
            });
        }

        function handleSentenceSelection(event) {
            const selectedSentenceId = event.target.value;
            verbalUnitsDisplayUl.innerHTML = ''; // Clear previous
            verbalUnitsSection.style.display = 'none';
            colorIndex = 0; // Reset color index for each new sentence selection


            if (!selectedSentenceId) {
                selectedSentenceDisplay.textContent = '';
                return;
            }

            selectedSentenceDisplay.textContent = `Displaying data for sentence: ${selectedSentenceId}`;
            
            const VUsInSentence = parsedVerbalUnits.filter(vu => vu.sentence === selectedSentenceId);

            if (VUsInSentence.length === 0) {
                verbalUnitsDisplayUl.innerHTML = '<li>No verbal units found for this sentence.</li>';
                verbalUnitsSection.style.display = 'block';
                return;
            }

            VUsInSentence.forEach(vu => {
                const tokensInVU = parsedTokens.filter(token => token.verbalunit === vu.vuid);
                const tokenCount = tokensInVU.length;

                const li = document.createElement('li');
                
                const vuColor = PASTEL_COLORS[colorIndex % PASTEL_COLORS.length];
                colorIndex++;

                const syntacticSpan = document.createElement('span');
                syntacticSpan.classList.add('syntactic-type');
                syntacticSpan.style.backgroundColor = vuColor;
                syntacticSpan.textContent = vu.syntactic_type;

                li.appendChild(syntacticSpan);
                li.innerHTML += ` (${vu.semantic_type || 'N/A'}) - Tokens: ${tokenCount}`;
                
                verbalUnitsDisplayUl.appendChild(li);
            });
            verbalUnitsSection.style.display = 'block';
        }

    </script>
</body>
</html>
```

**How to Use:**

1.  Save the code above as an HTML file (e.g., `greek_syntax_viewer.html`).
2.  Open this HTML file in your web browser.
3.  Click the "Choose a CEX file" button and select your local `.cex` file.
4.  If the file loads successfully and contains the required data blocks ("sentences", "verbal\_units", "tokens"):
    *   A dropdown menu will appear populated with sentence identifiers. These are sentences that are defined in the "sentences" block and also appear in the "verbal\_units" data.
    *   Select a sentence from the dropdown.
    *   The UI will display your selection.
    *   Below that, a list of verbal units for the selected sentence will appear. Each verbal unit will show:
        *   Its `syntactic_type` highlighted with a unique pastel color.
        *   Its `semantic_type` in parentheses.
        *   The count of tokens associated with that verbal unit.

**Key Features Implemented:**

1.  **Single HTML File:** All HTML, CSS, and JavaScript are in one file.
2.  **File Input:** `<input type="file">` allows users to select a local file.
3.  **CEX.js Integration:** The `cex.js` library is included via CDN.
4.  **Data Loading:** `parser.loadFromFile(file)` is used.
5.  **Data Collection:** `getDelimitedData("sentences")`, `getDelimitedData("verbal_units")`, and `getDelimitedData("tokens")` are called.
6.  **Data Parsing:**
    *   **Sentences:** Parsed for `sentence` (ID), `sequence`, `connector`.
    *   **Verbal Units:** Parsed for `vuid`, `syntactic_type`, `semantic_type`, `depth`, `sentence`.
    *   **Tokens:** Parsed for all 9 columns, with `verbalunit` being key for linking.
7.  **Sentence Selector UI:**
    *   A `<select>` dropdown is populated.
    *   It lists sentence identifiers from the "sentences" block *only if* those sentences are referenced in the "verbal\_units" data.
    *   The user's selection is displayed.
8.  **Verbal Unit Display:**
    *   When a sentence is selected, relevant verbal units are found.
    *   For each verbal unit:
        *   A unique pastel color is assigned (cycles through a predefined list).
        *   `syntactic_type` is displayed, highlighted with this color.
        *   `semantic_type` is shown in parentheses.
        *   The number of tokens belonging to that verbal unit is counted and displayed.
9.  **Basic Styling and Feedback:**
    *   Simple CSS for readability.
    *   Status messages for loading and errors.
    *   UI sections are hidden/shown appropriately.
    *   Error handling for missing data blocks or empty results.
10. **Data Clearing:** When a new file is selected, previous data and UI elements are cleared.
11. **Color Cycling:** The pastel colors are cycled through for different verbal units.

This provides a solid foundation for your web app! You can now expand on this by adding more complex visualizations or interactions.

### USER
  
Great! Tiny tweak: in the list of verbal units' syntactic, keep the background color as it is but make the text black.

### ASSISTANT
Okay, that's a simple change. We just need to adjust the CSS for the `.syntactic-type` class.

I'll modify this part in the `<style>` section:

```css
        .syntactic-type {
            padding: 2px 5px;
            border-radius: 3px;
            font-weight: bold;
            color: #fff; /* Text color will be white for better contrast with pastels */
        }
```

to:

```css
        .syntactic-type {
            padding: 2px 5px;
            border-radius: 3px;
            font-weight: bold;
            color: #000; /* Text color set to black */
        }
```

Here's the complete updated HTML file with that change:

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Greek Syntax Annotations Viewer</title>
    <script src="https://cdn.jsdelivr.net/gh/neelsmith/cex-lib/cex.js"></script>
    <style>
        body {
            font-family: sans-serif;
            margin: 20px;
            background-color: #f4f4f4;
            color: #333;
        }
        .container {
            background-color: #fff;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 0 10px rgba(0,0,0,0.1);
        }
        h1, h2 {
            color: #555;
        }
        label {
            display: block;
            margin-top: 10px;
            margin-bottom: 5px;
            font-weight: bold;
        }
        select, input[type="file"] {
            padding: 8px;
            margin-bottom: 15px;
            border-radius: 4px;
            border: 1px solid #ccc;
            width: 100%;
            box-sizing: border-box;
        }
        #selectedSentenceDisplay {
            margin-top: 15px;
            padding: 10px;
            background-color: #e9e9e9;
            border-left: 5px solid #007bff;
            font-style: italic;
        }
        #verbalUnitsDisplay ul {
            list-style-type: none;
            padding: 0;
        }
        #verbalUnitsDisplay li {
            padding: 8px;
            border-bottom: 1px solid #eee;
            margin-bottom: 5px;
        }
        #verbalUnitsDisplay li:last-child {
            border-bottom: none;
        }
        .syntactic-type {
            padding: 2px 5px;
            border-radius: 3px;
            font-weight: bold;
            color: #000; /* Text color set to black */
        }
        .error {
            color: red;
            font-weight: bold;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Greek Syntax Data Loader</h1>

        <label for="fileInput">Choose a CEX file:</label>
        <input type="file" id="fileInput" accept=".cex">

        <div id="sentenceSection" style="display: none;">
            <label for="sentenceSelector">Select a Sentence:</label>
            <select id="sentenceSelector"></select>
            <div id="selectedSentenceDisplay"></div>
        </div>

        <div id="verbalUnitsSection" style="display: none;">
            <h2>Verbal Units in Selected Sentence:</h2>
            <div id="verbalUnitsDisplay">
                <ul></ul>
            </div>
        </div>
        
        <div id="statusMessages"></div>

    </div>

    <script>
        // Global storage for parsed data
        let parsedSentences = [];
        let parsedVerbalUnits = [];
        let parsedTokens = [];

        // Predefined pastel colors for highlighting
        const PASTEL_COLORS = [
            "#FFB3BA", // Light Pink
            "#FFDFBA", // Light Peach
            "#FFFFBA", // Light Yellow
            "#BAFFC9", // Light Mint
            "#BAE1FF", // Light Blue
            "#E0BBE4", // Light Lavender
            "#FFDAC1", // Light Apricot
            "#B5EAD7", // Light Aqua
            "#F9C7CF", // Light Rose
            "#C7CEEA"  // Light Periwinkle
        ];
        let colorIndex = 0;

        const fileInput = document.getElementById('fileInput');
        const sentenceSelector = document.getElementById('sentenceSelector');
        const selectedSentenceDisplay = document.getElementById('selectedSentenceDisplay');
        const verbalUnitsDisplayUl = document.querySelector('#verbalUnitsDisplay ul');
        const sentenceSection = document.getElementById('sentenceSection');
        const verbalUnitsSection = document.getElementById('verbalUnitsSection');
        const statusMessages = document.getElementById('statusMessages');

        fileInput.addEventListener('change', handleFileSelect);
        sentenceSelector.addEventListener('change', handleSentenceSelection);

        function displayError(message) {
            statusMessages.innerHTML = `<p class="error">${message}</p>`;
            console.error(message);
        }

        function displayStatus(message) {
            statusMessages.innerHTML = `<p>${message}</p>`;
            console.log(message);
        }

        function clearPreviousData() {
            parsedSentences = [];
            parsedVerbalUnits = [];
            parsedTokens = [];
            sentenceSelector.innerHTML = '<option value="">-- Load a file --</option>';
            selectedSentenceDisplay.textContent = '';
            verbalUnitsDisplayUl.innerHTML = '';
            sentenceSection.style.display = 'none';
            verbalUnitsSection.style.display = 'none';
            statusMessages.innerHTML = '';
            colorIndex = 0;
        }

        function handleFileSelect(event) {
            clearPreviousData();
            const file = event.target.files[0];
            if (!file) {
                displayError('No file selected.');
                return;
            }

            displayStatus(`Loading ${file.name}...`);
            const parser = new CEXParser();
            parser.loadFromFile(file)
                .then(p => {
                    displayStatus('CEX data loaded! Processing...');
                    
                    const sentencesStr = p.getDelimitedData("sentences");
                    const verbalUnitsStr = p.getDelimitedData("verbal_units");
                    const tokensStr = p.getDelimitedData("tokens");

                    if (!sentencesStr || !verbalUnitsStr || !tokensStr) {
                        displayError('One or more required data blocks (sentences, verbal_units, tokens) are missing or empty in the CEX file.');
                        return;
                    }

                    // Parse Sentences: sentence|sequence|connector
                    parsedSentences = sentencesStr.trim().split('\n')
                        .map(line => {
                            const parts = line.split('|');
                            return { id: parts[0], sequence: parts[1], connector: parts[2] };
                        })
                        .filter(s => s.id); // Ensure id is present

                    // Parse Verbal Units: vuid|syntactic_type|semantic_type|depth|sentence
                    parsedVerbalUnits = verbalUnitsStr.trim().split('\n')
                        .map(line => {
                            const parts = line.split('|');
                            return { 
                                vuid: parts[0], 
                                syntactic_type: parts[1], 
                                semantic_type: parts[2], 
                                depth: parts[3], 
                                sentence: parts[4] 
                            };
                        })
                        .filter(vu => vu.vuid && vu.sentence); // Ensure vuid and sentence are present

                    // Parse Tokens: urn|reference|tokentype|text|verbalunit|node1|node1relation|node2|node2relation
                    parsedTokens = tokensStr.trim().split('\n')
                        .map(line => {
                            const parts = line.split('|');
                            return {
                                urn: parts[0],
                                reference: parts[1],
                                tokentype: parts[2],
                                text: parts[3],
                                verbalunit: parts[4],
                                node1: parts[5],
                                node1relation: parts[6],
                                node2: parts[7],
                                node2relation: parts[8]
                            };
                        })
                        .filter(t => t.urn && t.verbalunit); // Ensure urn and verbalunit are present

                    if (parsedVerbalUnits.length === 0) {
                        displayError('No verbal units found in the data. Cannot proceed.');
                        return;
                    }

                    populateSentenceSelector();
                    sentenceSection.style.display = 'block';
                    displayStatus(`Successfully processed ${file.name}. Select a sentence.`);

                })
                .catch(error => {
                    displayError(`Failed to load or parse CEX file: ${error.message}`);
                    console.error('Detailed error:', error);
                });
        }

        function populateSentenceSelector() {
            sentenceSelector.innerHTML = '<option value="">-- Select a Sentence --</option>'; // Reset

            const sentenceIdsInVUs = new Set(parsedVerbalUnits.map(vu => vu.sentence));
            
            // Original sentence identifiers from the "sentences" block
            const allSentenceIdsFromSentencesBlock = new Set(parsedSentences.map(s => s.id));

            // Filter these by checking if they are present in verbal units
            const displayableSentenceIds = [...allSentenceIdsFromSentencesBlock].filter(id => sentenceIdsInVUs.has(id));
            
            // Sort them if they have a numeric component for better ordering
            displayableSentenceIds.sort((a, b) => {
                const numA = parseInt(a.match(/\d+$/)?.[0] || a);
                const numB = parseInt(b.match(/\d+$/)?.[0] || b);
                if (!isNaN(numA) && !isNaN(numB)) return numA - numB;
                return a.localeCompare(b);
            });


            if (displayableSentenceIds.length === 0) {
                sentenceSelector.innerHTML = '<option value="">-- No sentences with verbal units --</option>';
                displayError('No sentences found that have associated verbal units.');
                return;
            }

            displayableSentenceIds.forEach(sentenceId => {
                const option = document.createElement('option');
                option.value = sentenceId;
                option.textContent = sentenceId;
                sentenceSelector.appendChild(option);
            });
        }

        function handleSentenceSelection(event) {
            const selectedSentenceId = event.target.value;
            verbalUnitsDisplayUl.innerHTML = ''; // Clear previous
            verbalUnitsSection.style.display = 'none';
            colorIndex = 0; // Reset color index for each new sentence selection


            if (!selectedSentenceId) {
                selectedSentenceDisplay.textContent = '';
                return;
            }

            selectedSentenceDisplay.textContent = `Displaying data for sentence: ${selectedSentenceId}`;
            
            const VUsInSentence = parsedVerbalUnits.filter(vu => vu.sentence === selectedSentenceId);

            if (VUsInSentence.length === 0) {
                verbalUnitsDisplayUl.innerHTML = '<li>No verbal units found for this sentence.</li>';
                verbalUnitsSection.style.display = 'block';
                return;
            }

            VUsInSentence.forEach(vu => {
                const tokensInVU = parsedTokens.filter(token => token.verbalunit === vu.vuid);
                const tokenCount = tokensInVU.length;

                const li = document.createElement('li');
                
                const vuColor = PASTEL_COLORS[colorIndex % PASTEL_COLORS.length];
                colorIndex++;

                const syntacticSpan = document.createElement('span');
                syntacticSpan.classList.add('syntactic-type');
                syntacticSpan.style.backgroundColor = vuColor;
                syntacticSpan.textContent = vu.syntactic_type;

                li.appendChild(syntacticSpan);
                li.innerHTML += ` (${vu.semantic_type || 'N/A'}) - Tokens: ${tokenCount}`;
                
                verbalUnitsDisplayUl.appendChild(li);
            });
            verbalUnitsSection.style.display = 'block';
        }

    </script>
</body>
</html>
```

The only change is in the `<style>` section:
`color: #fff;` was changed to `color: #000;` for the `.syntactic-type` class. Now, the text for the syntactic type will be black, while its background remains the assigned pastel color.

### USER
Another tiny tweak: do not include the header line of the table in forming the menu. The label `sentenced` should not appear in the menu.

### ASSISTANT
You're right, the header line from the CEX data (e.g., "sentence|sequence|connector") shouldn't be treated as an actual data record and definitely shouldn't appear in the sentence selection menu.

We can fix this by skipping the first line of each data block when parsing. The `slice(1)` array method is perfect for this, as it returns a new array containing all elements from the first index onwards, effectively skipping the element at index 0 (the header).

I'll apply this change to the parsing of `sentencesStr`, `verbalUnitsStr`, and `tokensStr`.

Here's the modified JavaScript part within the `<script>` tags. The HTML and CSS will remain the same as in the previous version with black text for syntactic types.

```javascript
    <script>
        // Global storage for parsed data
        let parsedSentences = [];
        let parsedVerbalUnits = [];
        let parsedTokens = [];

        // Predefined pastel colors for highlighting
        const PASTEL_COLORS = [
            "#FFB3BA", // Light Pink
            "#FFDFBA", // Light Peach
            "#FFFFBA", // Light Yellow
            "#BAFFC9", // Light Mint
            "#BAE1FF", // Light Blue
            "#E0BBE4", // Light Lavender
            "#FFDAC1", // Light Apricot
            "#B5EAD7", // Light Aqua
            "#F9C7CF", // Light Rose
            "#C7CEEA"  // Light Periwinkle
        ];
        let colorIndex = 0;

        const fileInput = document.getElementById('fileInput');
        const sentenceSelector = document.getElementById('sentenceSelector');
        const selectedSentenceDisplay = document.getElementById('selectedSentenceDisplay');
        const verbalUnitsDisplayUl = document.querySelector('#verbalUnitsDisplay ul');
        const sentenceSection = document.getElementById('sentenceSection');
        const verbalUnitsSection = document.getElementById('verbalUnitsSection');
        const statusMessages = document.getElementById('statusMessages');

        fileInput.addEventListener('change', handleFileSelect);
        sentenceSelector.addEventListener('change', handleSentenceSelection);

        function displayError(message) {
            statusMessages.innerHTML = `<p class="error">${message}</p>`;
            console.error(message);
        }

        function displayStatus(message) {
            statusMessages.innerHTML = `<p>${message}</p>`;
            console.log(message);
        }

        function clearPreviousData() {
            parsedSentences = [];
            parsedVerbalUnits = [];
            parsedTokens = [];
            sentenceSelector.innerHTML = '<option value="">-- Load a file --</option>';
            selectedSentenceDisplay.textContent = '';
            verbalUnitsDisplayUl.innerHTML = '';
            sentenceSection.style.display = 'none';
            verbalUnitsSection.style.display = 'none';
            statusMessages.innerHTML = '';
            colorIndex = 0;
        }

        function handleFileSelect(event) {
            clearPreviousData();
            const file = event.target.files[0];
            if (!file) {
                displayError('No file selected.');
                return;
            }

            displayStatus(`Loading ${file.name}...`);
            const parser = new CEXParser();
            parser.loadFromFile(file)
                .then(p => {
                    displayStatus('CEX data loaded! Processing...');
                    
                    const sentencesStr = p.getDelimitedData("sentences");
                    const verbalUnitsStr = p.getDelimitedData("verbal_units");
                    const tokensStr = p.getDelimitedData("tokens");

                    if (!sentencesStr || !verbalUnitsStr || !tokensStr) {
                        displayError('One or more required data blocks (sentences, verbal_units, tokens) are missing or empty in the CEX file.');
                        return;
                    }

                    // Parse Sentences: sentence|sequence|connector
                    // Skip the header line using slice(1)
                    const sentenceLines = sentencesStr.trim().split('\n');
                    parsedSentences = sentenceLines.length > 1 ? sentenceLines.slice(1) 
                        .map(line => {
                            const parts = line.split('|');
                            return { id: parts[0], sequence: parts[1], connector: parts[2] };
                        })
                        .filter(s => s.id && s.id.trim() !== "") : [];

                    // Parse Verbal Units: vuid|syntactic_type|semantic_type|depth|sentence
                    // Skip the header line using slice(1)
                    const verbalUnitLines = verbalUnitsStr.trim().split('\n');
                    parsedVerbalUnits = verbalUnitLines.length > 1 ? verbalUnitLines.slice(1)
                        .map(line => {
                            const parts = line.split('|');
                            return { 
                                vuid: parts[0], 
                                syntactic_type: parts[1], 
                                semantic_type: parts[2], 
                                depth: parts[3], 
                                sentence: parts[4] 
                            };
                        })
                        .filter(vu => vu.vuid && vu.vuid.trim() !== "" && vu.sentence && vu.sentence.trim() !== "") : [];

                    // Parse Tokens: urn|reference|tokentype|text|verbalunit|node1|node1relation|node2|node2relation
                    // Skip the header line using slice(1)
                    const tokenLines = tokensStr.trim().split('\n');
                    parsedTokens = tokenLines.length > 1 ? tokenLines.slice(1)
                        .map(line => {
                            const parts = line.split('|');
                            return {
                                urn: parts[0],
                                reference: parts[1],
                                tokentype: parts[2],
                                text: parts[3],
                                verbalunit: parts[4],
                                node1: parts[5],
                                node1relation: parts[6],
                                node2: parts[7],
                                node2relation: parts[8]
                            };
                        })
                        .filter(t => t.urn && t.urn.trim() !== "" && t.verbalunit && t.verbalunit.trim() !== "") : [];
                    
                    // console.log("Parsed Sentences:", parsedSentences);
                    // console.log("Parsed Verbal Units:", parsedVerbalUnits);
                    // console.log("Parsed Tokens:", parsedTokens);


                    if (parsedVerbalUnits.length === 0) {
                        displayError('No valid verbal units data found after excluding header. Cannot proceed.');
                        if (verbalUnitLines.length <=1 && verbalUnitsStr.trim() !== "") {
                            displayError('Verbal units data seems to only contain a header or is empty.');
                        }
                        return;
                    }
                     if (parsedSentences.length === 0 && sentenceLines.length > 1) {
                        displayStatus('Warning: No valid sentence data found after excluding header, though a sentence block was present.');
                    }


                    populateSentenceSelector();
                    sentenceSection.style.display = 'block';
                    displayStatus(`Successfully processed ${file.name}. Select a sentence.`);

                })
                .catch(error => {
                    displayError(`Failed to load or parse CEX file: ${error.message}`);
                    console.error('Detailed error:', error);
                });
        }

        function populateSentenceSelector() {
            sentenceSelector.innerHTML = '<option value="">-- Select a Sentence --</option>'; // Reset

            const sentenceIdsInVUs = new Set(parsedVerbalUnits.map(vu => vu.sentence));
            
            const allSentenceIdsFromSentencesBlock = new Set(parsedSentences.map(s => s.id));

            const displayableSentenceIds = [...allSentenceIdsFromSentencesBlock].filter(id => sentenceIdsInVUs.has(id));
            
            displayableSentenceIds.sort((a, b) => {
                const numA = parseInt(a.match(/\d+$/)?.[0] || a);
                const numB = parseInt(b.match(/\d+$/)?.[0] || b);
                if (!isNaN(numA) && !isNaN(numB)) return numA - numB;
                return a.localeCompare(b);
            });

            if (displayableSentenceIds.length === 0) {
                sentenceSelector.innerHTML = '<option value="">-- No sentences with verbal units --</option>';
                 if (parsedSentences.length > 0 && parsedVerbalUnits.length > 0) {
                    displayStatus('Info: While sentences and verbal units were loaded, no sentences from the "sentences" block are referenced in the "verbal_units" block, or vice-versa after filtering.');
                 } else if (parsedVerbalUnits.length > 0) {
                     displayStatus('Info: Verbal units loaded, but no corresponding entries in the "sentences" block to create a menu, or "sentences" block is missing/empty.');
                 }
                 else {
                    displayError('No sentences found that have associated verbal units.');
                 }
                return;
            }

            displayableSentenceIds.forEach(sentenceId => {
                const option = document.createElement('option');
                option.value = sentenceId;
                option.textContent = sentenceId;
                sentenceSelector.appendChild(option);
            });
        }

        function handleSentenceSelection(event) {
            const selectedSentenceId = event.target.value;
            verbalUnitsDisplayUl.innerHTML = ''; // Clear previous
            verbalUnitsSection.style.display = 'none';
            colorIndex = 0; 


            if (!selectedSentenceId) {
                selectedSentenceDisplay.textContent = '';
                return;
            }

            selectedSentenceDisplay.textContent = `Displaying data for sentence: ${selectedSentenceId}`;
            
            const VUsInSentence = parsedVerbalUnits.filter(vu => vu.sentence === selectedSentenceId);

            if (VUsInSentence.length === 0) {
                verbalUnitsDisplayUl.innerHTML = '<li>No verbal units found for this sentence.</li>';
                verbalUnitsSection.style.display = 'block';
                return;
            }

            VUsInSentence.forEach(vu => {
                const tokensInVU = parsedTokens.filter(token => token.verbalunit === vu.vuid);
                const tokenCount = tokensInVU.length;

                const li = document.createElement('li');
                
                const vuColor = PASTEL_COLORS[colorIndex % PASTEL_COLORS.length];
                colorIndex++;

                const syntacticSpan = document.createElement('span');
                syntacticSpan.classList.add('syntactic-type');
                syntacticSpan.style.backgroundColor = vuColor;
                syntacticSpan.textContent = vu.syntactic_type;

                li.appendChild(syntacticSpan);
                li.innerHTML += ` (${vu.semantic_type || 'N/A'}) - Tokens: ${tokenCount}`;
                
                verbalUnitsDisplayUl.appendChild(li);
            });
            verbalUnitsSection.style.display = 'block';
        }

    </script>
```

**Key changes in the JavaScript:**

1.  **Modified Parsing Logic:**
    For each data block (`sentencesStr`, `verbalUnitsStr`, `tokensStr`):
    *   We first get all lines: `const lines = dataStr.trim().split('\n');`
    *   Then we check if there's more than just a header line: `lines.length > 1`
    *   If so, we process `lines.slice(1)` (all lines except the first). Otherwise, we assign an empty array `[]`.
    *   The `filter` conditions were also slightly improved to ensure that the IDs or key fields are not just present but also non-empty strings after trimming (e.g., `s.id && s.id.trim() !== ""`).

    Example for sentences:
    ```javascript
    const sentenceLines = sentencesStr.trim().split('\n');
    parsedSentences = sentenceLines.length > 1 ? sentenceLines.slice(1) 
        .map(line => {
            const parts = line.split('|');
            return { id: parts[0], sequence: parts[1], connector: parts[2] };
        })
        .filter(s => s.id && s.id.trim() !== "") : [];
    ```
    This pattern is repeated for `parsedVerbalUnits` and `parsedTokens`.

2.  **Slightly more robust error/status messaging** in `handleFileSelect` and `populateSentenceSelector` for cases where data might be missing or only headers are present.

Now, when you load a CEX file, the header row of each data section will be correctly ignored, and labels like "sentence" will not appear in your sentence selection dropdown menu. The rest of the application (CSS, HTML structure) remains the same as the previous version.

### USER
Please display the full HTML file

### ASSISTANT
Okay, here is the complete HTML file with all the changes incorporated:

1.  **CSS:** Syntactic type text color is black.
2.  **JavaScript:** Header lines from CEX data blocks are skipped during parsing.

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Greek Syntax Annotations Viewer</title>
    <script src="https://cdn.jsdelivr.net/gh/neelsmith/cex-lib/cex.js"></script>
    <style>
        body {
            font-family: sans-serif;
            margin: 20px;
            background-color: #f4f4f4;
            color: #333;
        }
        .container {
            background-color: #fff;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 0 10px rgba(0,0,0,0.1);
        }
        h1, h2 {
            color: #555;
        }
        label {
            display: block;
            margin-top: 10px;
            margin-bottom: 5px;
            font-weight: bold;
        }
        select, input[type="file"] {
            padding: 8px;
            margin-bottom: 15px;
            border-radius: 4px;
            border: 1px solid #ccc;
            width: 100%;
            box-sizing: border-box;
        }
        #selectedSentenceDisplay {
            margin-top: 15px;
            padding: 10px;
            background-color: #e9e9e9;
            border-left: 5px solid #007bff;
            font-style: italic;
        }
        #verbalUnitsDisplay ul {
            list-style-type: none;
            padding: 0;
        }
        #verbalUnitsDisplay li {
            padding: 8px;
            border-bottom: 1px solid #eee;
            margin-bottom: 5px;
        }
        #verbalUnitsDisplay li:last-child {
            border-bottom: none;
        }
        .syntactic-type {
            padding: 2px 5px;
            border-radius: 3px;
            font-weight: bold;
            color: #000; /* Text color set to black */
        }
        .error {
            color: red;
            font-weight: bold;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Greek Syntax Data Loader</h1>

        <label for="fileInput">Choose a CEX file:</label>
        <input type="file" id="fileInput" accept=".cex">

        <div id="sentenceSection" style="display: none;">
            <label for="sentenceSelector">Select a Sentence:</label>
            <select id="sentenceSelector"></select>
            <div id="selectedSentenceDisplay"></div>
        </div>

        <div id="verbalUnitsSection" style="display: none;">
            <h2>Verbal Units in Selected Sentence:</h2>
            <div id="verbalUnitsDisplay">
                <ul></ul>
            </div>
        </div>
        
        <div id="statusMessages"></div>

    </div>

    <script>
        // Global storage for parsed data
        let parsedSentences = [];
        let parsedVerbalUnits = [];
        let parsedTokens = [];

        // Predefined pastel colors for highlighting
        const PASTEL_COLORS = [
            "#FFB3BA", // Light Pink
            "#FFDFBA", // Light Peach
            "#FFFFBA", // Light Yellow
            "#BAFFC9", // Light Mint
            "#BAE1FF", // Light Blue
            "#E0BBE4", // Light Lavender
            "#FFDAC1", // Light Apricot
            "#B5EAD7", // Light Aqua
            "#F9C7CF", // Light Rose
            "#C7CEEA"  // Light Periwinkle
        ];
        let colorIndex = 0;

        const fileInput = document.getElementById('fileInput');
        const sentenceSelector = document.getElementById('sentenceSelector');
        const selectedSentenceDisplay = document.getElementById('selectedSentenceDisplay');
        const verbalUnitsDisplayUl = document.querySelector('#verbalUnitsDisplay ul');
        const sentenceSection = document.getElementById('sentenceSection');
        const verbalUnitsSection = document.getElementById('verbalUnitsSection');
        const statusMessages = document.getElementById('statusMessages');

        fileInput.addEventListener('change', handleFileSelect);
        sentenceSelector.addEventListener('change', handleSentenceSelection);

        function displayError(message) {
            statusMessages.innerHTML = `<p class="error">${message}</p>`;
            console.error(message);
        }

        function displayStatus(message) {
            statusMessages.innerHTML = `<p>${message}</p>`;
            console.log(message);
        }

        function clearPreviousData() {
            parsedSentences = [];
            parsedVerbalUnits = [];
            parsedTokens = [];
            sentenceSelector.innerHTML = '<option value="">-- Load a file --</option>';
            selectedSentenceDisplay.textContent = '';
            verbalUnitsDisplayUl.innerHTML = '';
            sentenceSection.style.display = 'none';
            verbalUnitsSection.style.display = 'none';
            statusMessages.innerHTML = '';
            colorIndex = 0;
        }

        function handleFileSelect(event) {
            clearPreviousData();
            const file = event.target.files[0];
            if (!file) {
                displayError('No file selected.');
                return;
            }

            displayStatus(`Loading ${file.name}...`);
            const parser = new CEXParser();
            parser.loadFromFile(file)
                .then(p => {
                    displayStatus('CEX data loaded! Processing...');
                    
                    const sentencesStr = p.getDelimitedData("sentences");
                    const verbalUnitsStr = p.getDelimitedData("verbal_units");
                    const tokensStr = p.getDelimitedData("tokens");

                    if (!sentencesStr || !verbalUnitsStr || !tokensStr) {
                        displayError('One or more required data blocks (sentences, verbal_units, tokens) are missing or empty in the CEX file.');
                        return;
                    }

                    // Parse Sentences: sentence|sequence|connector
                    // Skip the header line using slice(1)
                    const sentenceLines = sentencesStr.trim().split('\n');
                    parsedSentences = sentenceLines.length > 1 ? sentenceLines.slice(1) 
                        .map(line => {
                            const parts = line.split('|');
                            return { id: parts[0], sequence: parts[1], connector: parts[2] };
                        })
                        .filter(s => s.id && s.id.trim() !== "") : [];

                    // Parse Verbal Units: vuid|syntactic_type|semantic_type|depth|sentence
                    // Skip the header line using slice(1)
                    const verbalUnitLines = verbalUnitsStr.trim().split('\n');
                    parsedVerbalUnits = verbalUnitLines.length > 1 ? verbalUnitLines.slice(1)
                        .map(line => {
                            const parts = line.split('|');
                            return { 
                                vuid: parts[0], 
                                syntactic_type: parts[1], 
                                semantic_type: parts[2], 
                                depth: parts[3], 
                                sentence: parts[4] 
                            };
                        })
                        .filter(vu => vu.vuid && vu.vuid.trim() !== "" && vu.sentence && vu.sentence.trim() !== "") : [];

                    // Parse Tokens: urn|reference|tokentype|text|verbalunit|node1|node1relation|node2|node2relation
                    // Skip the header line using slice(1)
                    const tokenLines = tokensStr.trim().split('\n');
                    parsedTokens = tokenLines.length > 1 ? tokenLines.slice(1)
                        .map(line => {
                            const parts = line.split('|');
                            return {
                                urn: parts[0],
                                reference: parts[1],
                                tokentype: parts[2],
                                text: parts[3],
                                verbalunit: parts[4],
                                node1: parts[5],
                                node1relation: parts[6],
                                node2: parts[7],
                                node2relation: parts[8]
                            };
                        })
                        .filter(t => t.urn && t.urn.trim() !== "" && t.verbalunit && t.verbalunit.trim() !== "") : [];
                    
                    if (parsedVerbalUnits.length === 0) {
                        let errorMsg = 'No valid verbal units data found after excluding header. Cannot proceed.';
                        if (verbalUnitLines.length <=1 && verbalUnitsStr.trim() !== "") {
                            errorMsg = 'Verbal units data seems to only contain a header or is empty.';
                        }
                        displayError(errorMsg);
                        return;
                    }
                     if (parsedSentences.length === 0 && sentenceLines.length > 1) {
                        displayStatus('Warning: No valid sentence data found after excluding header, though a "sentences" block was present.');
                    }


                    populateSentenceSelector();
                    sentenceSection.style.display = 'block';
                    displayStatus(`Successfully processed ${file.name}. Select a sentence.`);

                })
                .catch(error => {
                    displayError(`Failed to load or parse CEX file: ${error.message}`);
                    console.error('Detailed error:', error);
                });
        }

        function populateSentenceSelector() {
            sentenceSelector.innerHTML = '<option value="">-- Select a Sentence --</option>'; // Reset

            const sentenceIdsInVUs = new Set(parsedVerbalUnits.map(vu => vu.sentence));
            
            const allSentenceIdsFromSentencesBlock = new Set(parsedSentences.map(s => s.id));

            const displayableSentenceIds = [...allSentenceIdsFromSentencesBlock].filter(id => sentenceIdsInVUs.has(id));
            
            displayableSentenceIds.sort((a, b) => {
                const numA = parseInt(a.match(/\d+$/)?.[0] || a);
                const numB = parseInt(b.match(/\d+$/)?.[0] || b);
                if (!isNaN(numA) && !isNaN(numB)) return numA - numB;
                return a.localeCompare(b);
            });

            if (displayableSentenceIds.length === 0) {
                sentenceSelector.innerHTML = '<option value="">-- No sentences with verbal units --</option>';
                 if (parsedSentences.length > 0 && parsedVerbalUnits.length > 0) {
                    displayStatus('Info: While sentences and verbal units were loaded, no sentences from the "sentences" block are referenced in the "verbal_units" block, or vice-versa after filtering for valid data.');
                 } else if (parsedVerbalUnits.length > 0 && parsedSentences.length === 0) {
                     displayStatus('Info: Verbal units loaded, but the "sentences" block is missing, empty, or only contains a header. Cannot populate sentence menu.');
                 }
                 else {
                    displayError('No sentences found that have associated verbal units. Check data integrity.');
                 }
                return;
            }

            displayableSentenceIds.forEach(sentenceId => {
                const option = document.createElement('option');
                option.value = sentenceId;
                option.textContent = sentenceId;
                sentenceSelector.appendChild(option);
            });
        }

        function handleSentenceSelection(event) {
            const selectedSentenceId = event.target.value;
            verbalUnitsDisplayUl.innerHTML = ''; // Clear previous
            verbalUnitsSection.style.display = 'none';
            colorIndex = 0; 


            if (!selectedSentenceId) {
                selectedSentenceDisplay.textContent = '';
                return;
            }

            selectedSentenceDisplay.textContent = `Displaying data for sentence: ${selectedSentenceId}`;
            
            const VUsInSentence = parsedVerbalUnits.filter(vu => vu.sentence === selectedSentenceId);

            if (VUsInSentence.length === 0) {
                verbalUnitsDisplayUl.innerHTML = '<li>No verbal units found for this sentence.</li>';
                verbalUnitsSection.style.display = 'block';
                return;
            }

            VUsInSentence.forEach(vu => {
                const tokensInVU = parsedTokens.filter(token => token.verbalunit === vu.vuid);
                const tokenCount = tokensInVU.length;

                const li = document.createElement('li');
                
                const vuColor = PASTEL_COLORS[colorIndex % PASTEL_COLORS.length];
                colorIndex++;

                const syntacticSpan = document.createElement('span');
                syntacticSpan.classList.add('syntactic-type');
                syntacticSpan.style.backgroundColor = vuColor;
                syntacticSpan.textContent = vu.syntactic_type;

                li.appendChild(syntacticSpan);
                li.innerHTML += ` (${vu.semantic_type || 'N/A'}) - Tokens: ${tokenCount}`;
                
                verbalUnitsDisplayUl.appendChild(li);
            });
            verbalUnitsSection.style.display = 'block';
        }

    </script>
</body>
</html>
```

### USER
Beautiful. Now we're going to develop a series of displays for the selected tokens. Make sure they are sorted by the value of numeric `reference` column. Create a single string by joing the `text` value of each token, separated by a space.
Display the sentence text against a white ground, and color each token according to its verbal unit.

### ASSISTANT
Okay, this is an excellent next step! We'll add a new section to display the sentence text with tokens colored by their verbal unit.

Here's how we'll modify the code:

1.  **HTML:** Add a new `div` to hold the sentence text display.
2.  **CSS:** Add styling for the individual token spans within the sentence display.
3.  **JavaScript:**
    *   In `handleSentenceSelection`:
        *   When processing verbal units for the list, we'll store the assigned color directly on each verbal unit object.
        *   We'll gather all tokens belonging to the verbal units of the selected sentence.
        *   These tokens will be sorted numerically by their `reference` column.
        *   We'll then iterate through the sorted tokens, create `<span>` elements for each token's `text`, and style these spans with the background color of their parent verbal unit.
    *   Update `clearPreviousData` to also clear and hide this new sentence display section.

Here is the complete updated HTML file:

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Greek Syntax Annotations Viewer</title>
    <script src="https://cdn.jsdelivr.net/gh/neelsmith/cex-lib/cex.js"></script>
    <style>
        body {
            font-family: sans-serif;
            margin: 20px;
            background-color: #f4f4f4;
            color: #333;
        }
        .container {
            background-color: #fff;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 0 10px rgba(0,0,0,0.1);
        }
        h1, h2 {
            color: #555;
        }
        label {
            display: block;
            margin-top: 10px;
            margin-bottom: 5px;
            font-weight: bold;
        }
        select, input[type="file"] {
            padding: 8px;
            margin-bottom: 15px;
            border-radius: 4px;
            border: 1px solid #ccc;
            width: 100%;
            box-sizing: border-box;
        }
        #selectedSentenceDisplay {
            margin-top: 15px;
            padding: 10px;
            background-color: #e9e9e9;
            border-left: 5px solid #007bff;
            font-style: italic;
        }
        #verbalUnitsDisplay ul {
            list-style-type: none;
            padding: 0;
        }
        #verbalUnitsDisplay li {
            padding: 8px;
            border-bottom: 1px solid #eee;
            margin-bottom: 5px;
        }
        #verbalUnitsDisplay li:last-child {
            border-bottom: none;
        }
        .syntactic-type {
            padding: 2px 5px;
            border-radius: 3px;
            font-weight: bold;
            color: #000; /* Text color set to black */
        }
        #sentenceTextDisplay {
            background-color: white;
            padding: 15px;
            margin-top: 10px;
            border: 1px solid #ddd;
            border-radius: 4px;
            line-height: 2; /* Increased line-height for readability of tokens */
        }
        .token-span {
            padding: 2px 4px;
            margin-right: 4px; 
            margin-bottom: 4px; /* For wrapped lines */
            display: inline-block; 
            border-radius: 3px;
            color: #000; /* Black text for tokens */
        }
        .error {
            color: red;
            font-weight: bold;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Greek Syntax Data Loader</h1>

        <label for="fileInput">Choose a CEX file:</label>
        <input type="file" id="fileInput" accept=".cex">

        <div id="sentenceSection" style="display: none;">
            <label for="sentenceSelector">Select a Sentence:</label>
            <select id="sentenceSelector"></select>
            <div id="selectedSentenceDisplay"></div>
        </div>

        <div id="verbalUnitsSection" style="display: none;">
            <h2>Verbal Units in Selected Sentence:</h2>
            <div id="verbalUnitsDisplay">
                <ul></ul>
            </div>
        </div>

        <div id="sentenceDisplaySection" style="display: none;">
            <h2>Sentence Text:</h2>
            <div id="sentenceTextDisplay">
                <!-- Tokens will be rendered here -->
            </div>
        </div>
        
        <div id="statusMessages"></div>

    </div>

    <script>
        // Global storage for parsed data
        let parsedSentences = [];
        let parsedVerbalUnits = [];
        let parsedTokens = [];

        // Predefined pastel colors for highlighting
        const PASTEL_COLORS = [
            "#FFB3BA", "#FFDFBA", "#FFFFBA", "#BAFFC9", "#BAE1FF",
            "#E0BBE4", "#FFDAC1", "#B5EAD7", "#F9C7CF", "#C7CEEA"
        ];
        let globalColorIndex = 0; // Renamed to avoid confusion with local color index

        const fileInput = document.getElementById('fileInput');
        const sentenceSelector = document.getElementById('sentenceSelector');
        const selectedSentenceDisplay = document.getElementById('selectedSentenceDisplay');
        const verbalUnitsDisplayUl = document.querySelector('#verbalUnitsDisplay ul');
        const sentenceSection = document.getElementById('sentenceSection');
        const verbalUnitsSection = document.getElementById('verbalUnitsSection');
        const sentenceDisplaySection = document.getElementById('sentenceDisplaySection');
        const sentenceTextDisplay = document.getElementById('sentenceTextDisplay');
        const statusMessages = document.getElementById('statusMessages');

        fileInput.addEventListener('change', handleFileSelect);
        sentenceSelector.addEventListener('change', handleSentenceSelection);

        function displayError(message) {
            statusMessages.innerHTML = `<p class="error">${message}</p>`;
            console.error(message);
        }

        function displayStatus(message) {
            statusMessages.innerHTML = `<p>${message}</p>`;
            console.log(message);
        }

        function clearPreviousData() {
            parsedSentences = [];
            parsedVerbalUnits = [];
            parsedTokens = [];
            sentenceSelector.innerHTML = '<option value="">-- Load a file --</option>';
            selectedSentenceDisplay.textContent = '';
            verbalUnitsDisplayUl.innerHTML = '';
            sentenceTextDisplay.innerHTML = '';
            sentenceSection.style.display = 'none';
            verbalUnitsSection.style.display = 'none';
            sentenceDisplaySection.style.display = 'none';
            statusMessages.innerHTML = '';
            globalColorIndex = 0; 
        }

        function handleFileSelect(event) {
            clearPreviousData();
            const file = event.target.files[0];
            if (!file) {
                displayError('No file selected.');
                return;
            }

            displayStatus(`Loading ${file.name}...`);
            const parser = new CEXParser();
            parser.loadFromFile(file)
                .then(p => {
                    displayStatus('CEX data loaded! Processing...');
                    
                    const sentencesStr = p.getDelimitedData("sentences");
                    const verbalUnitsStr = p.getDelimitedData("verbal_units");
                    const tokensStr = p.getDelimitedData("tokens");

                    if (!sentencesStr || !verbalUnitsStr || !tokensStr) {
                        displayError('One or more required data blocks (sentences, verbal_units, tokens) are missing or empty in the CEX file.');
                        return;
                    }

                    const sentenceLines = sentencesStr.trim().split('\n');
                    parsedSentences = sentenceLines.length > 1 ? sentenceLines.slice(1) 
                        .map(line => {
                            const parts = line.split('|');
                            return { id: parts[0], sequence: parts[1], connector: parts[2] };
                        })
                        .filter(s => s.id && s.id.trim() !== "") : [];

                    const verbalUnitLines = verbalUnitsStr.trim().split('\n');
                    parsedVerbalUnits = verbalUnitLines.length > 1 ? verbalUnitLines.slice(1)
                        .map(line => {
                            const parts = line.split('|');
                            return { 
                                vuid: parts[0], 
                                syntactic_type: parts[1], 
                                semantic_type: parts[2], 
                                depth: parts[3], 
                                sentence: parts[4] 
                            };
                        })
                        .filter(vu => vu.vuid && vu.vuid.trim() !== "" && vu.sentence && vu.sentence.trim() !== "") : [];

                    const tokenLines = tokensStr.trim().split('\n');
                    parsedTokens = tokenLines.length > 1 ? tokenLines.slice(1)
                        .map(line => {
                            const parts = line.split('|');
                            return {
                                urn: parts[0],
                                reference: parts[1], // Keep as string for now, parse to int when sorting
                                tokentype: parts[2],
                                text: parts[3],
                                verbalunit: parts[4],
                                node1: parts[5],
                                node1relation: parts[6],
                                node2: parts[7],
                                node2relation: parts[8]
                            };
                        })
                        .filter(t => t.urn && t.urn.trim() !== "" && t.verbalunit && t.verbalunit.trim() !== "") : [];
                    
                    if (parsedVerbalUnits.length === 0) {
                        let errorMsg = 'No valid verbal units data found after excluding header. Cannot proceed.';
                        if (verbalUnitLines.length <=1 && verbalUnitsStr.trim() !== "") {
                            errorMsg = 'Verbal units data seems to only contain a header or is empty.';
                        }
                        displayError(errorMsg);
                        return;
                    }
                     if (parsedSentences.length === 0 && sentenceLines.length > 1) {
                        displayStatus('Warning: No valid sentence data found after excluding header, though a "sentences" block was present.');
                    }

                    populateSentenceSelector();
                    sentenceSection.style.display = 'block';
                    displayStatus(`Successfully processed ${file.name}. Select a sentence.`);
                })
                .catch(error => {
                    displayError(`Failed to load or parse CEX file: ${error.message}`);
                    console.error('Detailed error:', error);
                });
        }

        function populateSentenceSelector() {
            sentenceSelector.innerHTML = '<option value="">-- Select a Sentence --</option>'; 
            const sentenceIdsInVUs = new Set(parsedVerbalUnits.map(vu => vu.sentence));
            const allSentenceIdsFromSentencesBlock = new Set(parsedSentences.map(s => s.id));
            const displayableSentenceIds = [...allSentenceIdsFromSentencesBlock].filter(id => sentenceIdsInVUs.has(id));
            
            displayableSentenceIds.sort((a, b) => {
                const numA = parseInt(a.match(/\d+$/)?.[0] || a);
                const numB = parseInt(b.match(/\d+$/)?.[0] || b);
                if (!isNaN(numA) && !isNaN(numB)) return numA - numB;
                return a.localeCompare(b);
            });

            if (displayableSentenceIds.length === 0) {
                sentenceSelector.innerHTML = '<option value="">-- No sentences with verbal units --</option>';
                 if (parsedSentences.length > 0 && parsedVerbalUnits.length > 0) {
                    displayStatus('Info: While sentences and verbal units were loaded, no sentences from the "sentences" block are referenced in the "verbal_units" block, or vice-versa after filtering for valid data.');
                 } else if (parsedVerbalUnits.length > 0 && parsedSentences.length === 0) {
                     displayStatus('Info: Verbal units loaded, but the "sentences" block is missing, empty, or only contains a header. Cannot populate sentence menu.');
                 } else {
                    displayError('No sentences found that have associated verbal units. Check data integrity.');
                 }
                return;
            }
            displayableSentenceIds.forEach(sentenceId => {
                const option = document.createElement('option');
                option.value = sentenceId;
                option.textContent = sentenceId;
                sentenceSelector.appendChild(option);
            });
        }

        function handleSentenceSelection(event) {
            const selectedSentenceId = event.target.value;
            verbalUnitsDisplayUl.innerHTML = ''; 
            sentenceTextDisplay.innerHTML = '';
            verbalUnitsSection.style.display = 'none';
            sentenceDisplaySection.style.display = 'none';
            let localColorIndex = 0; // Use a local index for assigning colors to VUs in this sentence


            if (!selectedSentenceId) {
                selectedSentenceDisplay.textContent = '';
                return;
            }

            selectedSentenceDisplay.textContent = `Displaying data for sentence: ${selectedSentenceId}`;
            
            // 1. Get VUs for the sentence and assign/store colors
            const VUsInSentence = parsedVerbalUnits
                .filter(vu => vu.sentence === selectedSentenceId)
                .map(vu_orig => {
                    const color = PASTEL_COLORS[localColorIndex % PASTEL_COLORS.length];
                    localColorIndex++;
                    return { ...vu_orig, displayColor: color }; // Store the assigned color
                });

            if (VUsInSentence.length === 0) {
                verbalUnitsDisplayUl.innerHTML = '<li>No verbal units found for this sentence.</li>';
                verbalUnitsSection.style.display = 'block';
                // No sentence text to display if no VUs
                sentenceDisplaySection.style.display = 'block';
                sentenceTextDisplay.innerHTML = '<em>No verbal units (and thus no tokens) for this sentence.</em>';
                return;
            }

            // Populate Verbal Units List
            VUsInSentence.forEach(vu => {
                const tokensInThisVU = parsedTokens.filter(token => token.verbalunit === vu.vuid);
                const tokenCount = tokensInThisVU.length;

                const li = document.createElement('li');
                const syntacticSpan = document.createElement('span');
                syntacticSpan.classList.add('syntactic-type');
                syntacticSpan.style.backgroundColor = vu.displayColor; // Use stored color
                syntacticSpan.textContent = vu.syntactic_type;

                li.appendChild(syntacticSpan);
                li.innerHTML += ` (${vu.semantic_type || 'N/A'}) - Tokens: ${tokenCount}`;
                verbalUnitsDisplayUl.appendChild(li);
            });
            verbalUnitsSection.style.display = 'block';

            // 2. Collect all tokens for the selected sentence's VUs
            const vuIdsInSentence = VUsInSentence.map(vu => vu.vuid);
            let sentenceTokens = parsedTokens.filter(token => vuIdsInSentence.includes(token.verbalunit));

            // 3. Sort tokens by numeric reference
            sentenceTokens.sort((a, b) => {
                const refA = parseInt(a.reference, 10);
                const refB = parseInt(b.reference, 10);
                // Handle cases where reference might not be a number or is missing
                if (isNaN(refA) && isNaN(refB)) return 0;
                if (isNaN(refA)) return 1; // Put NaNs at the end
                if (isNaN(refB)) return -1; // Put NaNs at the end
                return refA - refB;
            });

            // 4. Display sorted tokens with VU colors
            if (sentenceTokens.length > 0) {
                sentenceTokens.forEach(token => {
                    const tokenSpan = document.createElement('span');
                    tokenSpan.classList.add('token-span');
                    tokenSpan.textContent = token.text; 
                    
                    const parentVU = VUsInSentence.find(vu => vu.vuid === token.verbalunit);
                    if (parentVU && parentVU.displayColor) {
                        tokenSpan.style.backgroundColor = parentVU.displayColor;
                    } else {
                        // Fallback if token's VU not found or has no color (should be rare)
                        tokenSpan.style.backgroundColor = '#eee'; // Neutral background
                        tokenSpan.style.color = '#555';
                    }
                    sentenceTextDisplay.appendChild(tokenSpan);
                });
            } else {
                sentenceTextDisplay.innerHTML = '<em>No tokens found associated with the verbal units of this sentence.</em>';
            }
            sentenceDisplaySection.style.display = 'block';
        }

    </script>
</body>
</html>
```

Key changes:

1.  **HTML (`<body>`):**
    ```html
    <div id="sentenceDisplaySection" style="display: none;">
        <h2>Sentence Text:</h2>
        <div id="sentenceTextDisplay">
            <!-- Tokens will be rendered here -->
        </div>
    </div>
    ```

2.  **CSS (`<style>`):**
    ```css
    #sentenceTextDisplay {
        background-color: white;
        padding: 15px;
        margin-top: 10px;
        border: 1px solid #ddd;
        border-radius: 4px;
        line-height: 2; /* Increased line-height for readability of tokens */
    }
    .token-span {
        padding: 2px 4px;
        margin-right: 4px; 
        margin-bottom: 4px; /* For wrapped lines */
        display: inline-block; 
        border-radius: 3px;
        color: #000; /* Black text for tokens */
    }
    ```

3.  **JavaScript (`<script>`):**
    *   **`clearPreviousData()`:** Added lines to clear and hide `sentenceTextDisplay` and `sentenceDisplaySection`.
        ```javascript
        sentenceTextDisplay.innerHTML = '';
        sentenceDisplaySection.style.display = 'none';
        ```
    *   **`handleSentenceSelection()`:**
        *   A `localColorIndex` is used to assign colors to VUs for the current sentence, ensuring distinct colors within that sentence's VUs.
        *   When mapping `VUsInSentence`, the color is stored as `displayColor` on each VU object:
            ```javascript
            .map(vu_orig => {
                const color = PASTEL_COLORS[localColorIndex % PASTEL_COLORS.length];
                localColorIndex++;
                return { ...vu_orig, displayColor: color }; // Store the assigned color
            });
            ```
        *   Tokens for the sentence are collected based on the `VUsInSentence`.
        *   Tokens are sorted: `sentenceTokens.sort((a, b) => { const refA = parseInt(a.reference, 10); ... });`
        *   Sorted tokens are iterated, and `<span>` elements are created:
            ```javascript
            const tokenSpan = document.createElement('span');
            tokenSpan.classList.add('token-span');
            tokenSpan.textContent = token.text; 
            
            const parentVU = VUsInSentence.find(vu => vu.vuid === token.verbalunit);
            if (parentVU && parentVU.displayColor) {
                tokenSpan.style.backgroundColor = parentVU.displayColor;
            } // ... (fallback styling)
            sentenceTextDisplay.appendChild(tokenSpan);
            ```
        *   The `sentenceDisplaySection` and `sentenceTextDisplay` are shown.

Now, when you select a sentence, you'll see the list of its verbal units as before, and below that, the sentence's text reconstructed from its tokens, with each token highlighted in the color of its associated verbal unit.

### USER
Let's futher decorate this display of tokens for specific values of its `node1relation`. If the value is `unit verb`, add a box around the token; if it is `subject`, add an underline; if it is `direct object` or `predicate`, add both and overline and an underline.

### ASSISTANT
Okay, this will add another layer of visual information to the token display. We'll introduce new CSS classes for the decorations and then apply them in the JavaScript based on the `node1relation` value.

Here's the plan:

1.  **CSS:**
    *   Define `.token-unit-verb` for the box.
    *   Define `.token-subject` for the underline.
    *   Define `.token-direct-object-predicate` for both overline and underline.
2.  **JavaScript (`handleSentenceSelection`):**
    *   When creating each `tokenSpan`, after setting its background color, check the `token.node1relation`.
    *   Add the appropriate CSS class(es) to the `tokenSpan`.

Here's the complete updated HTML file:

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Greek Syntax Annotations Viewer</title>
    <script src="https://cdn.jsdelivr.net/gh/neelsmith/cex-lib/cex.js"></script>
    <style>
        body {
            font-family: sans-serif;
            margin: 20px;
            background-color: #f4f4f4;
            color: #333;
        }
        .container {
            background-color: #fff;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 0 10px rgba(0,0,0,0.1);
        }
        h1, h2 {
            color: #555;
        }
        label {
            display: block;
            margin-top: 10px;
            margin-bottom: 5px;
            font-weight: bold;
        }
        select, input[type="file"] {
            padding: 8px;
            margin-bottom: 15px;
            border-radius: 4px;
            border: 1px solid #ccc;
            width: 100%;
            box-sizing: border-box;
        }
        #selectedSentenceDisplay {
            margin-top: 15px;
            padding: 10px;
            background-color: #e9e9e9;
            border-left: 5px solid #007bff;
            font-style: italic;
        }
        #verbalUnitsDisplay ul {
            list-style-type: none;
            padding: 0;
        }
        #verbalUnitsDisplay li {
            padding: 8px;
            border-bottom: 1px solid #eee;
            margin-bottom: 5px;
        }
        #verbalUnitsDisplay li:last-child {
            border-bottom: none;
        }
        .syntactic-type {
            padding: 2px 5px;
            border-radius: 3px;
            font-weight: bold;
            color: #000; /* Text color set to black */
        }
        #sentenceTextDisplay {
            background-color: white;
            padding: 15px;
            margin-top: 10px;
            border: 1px solid #ddd;
            border-radius: 4px;
            line-height: 2.2; /* Increased line-height for readability of tokens & decorations */
            word-spacing: 2px; /* Add a bit more space between token-spans */
        }
        .token-span {
            padding: 3px 5px; /* Slightly more padding for decorations */
            margin-right: 3px; 
            margin-bottom: 5px; /* For wrapped lines and decorations */
            display: inline-block; 
            border-radius: 3px;
            color: #000; /* Black text for tokens */
            position: relative; /* For potential future absolute positioning of complex decorations */
        }
        .token-unit-verb {
            border: 1.5px solid #444;
            /* Adjust padding slightly if border makes it too tight, but original padding should be okay */
        }
        .token-subject {
            text-decoration: underline;
            text-decoration-color: #333;
            text-decoration-thickness: 1.5px;
        }
        .token-direct-object-predicate {
            text-decoration: underline overline;
            text-decoration-color: #333;
            text-decoration-thickness: 1.5px;
        }
        .error {
            color: red;
            font-weight: bold;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Greek Syntax Data Loader</h1>

        <label for="fileInput">Choose a CEX file:</label>
        <input type="file" id="fileInput" accept=".cex">

        <div id="sentenceSection" style="display: none;">
            <label for="sentenceSelector">Select a Sentence:</label>
            <select id="sentenceSelector"></select>
            <div id="selectedSentenceDisplay"></div>
        </div>

        <div id="verbalUnitsSection" style="display: none;">
            <h2>Verbal Units in Selected Sentence:</h2>
            <div id="verbalUnitsDisplay">
                <ul></ul>
            </div>
        </div>

        <div id="sentenceDisplaySection" style="display: none;">
            <h2>Sentence Text (with token decorations):</h2>
            <div id="sentenceTextDisplay">
                <!-- Tokens will be rendered here -->
            </div>
        </div>
        
        <div id="statusMessages"></div>

    </div>

    <script>
        // Global storage for parsed data
        let parsedSentences = [];
        let parsedVerbalUnits = [];
        let parsedTokens = [];

        const PASTEL_COLORS = [
            "#FFB3BA", "#FFDFBA", "#FFFFBA", "#BAFFC9", "#BAE1FF",
            "#E0BBE4", "#FFDAC1", "#B5EAD7", "#F9C7CF", "#C7CEEA"
        ];
        // No need for globalColorIndex if localColorIndex is reset per sentence selection

        const fileInput = document.getElementById('fileInput');
        const sentenceSelector = document.getElementById('sentenceSelector');
        const selectedSentenceDisplay = document.getElementById('selectedSentenceDisplay');
        const verbalUnitsDisplayUl = document.querySelector('#verbalUnitsDisplay ul');
        const sentenceSection = document.getElementById('sentenceSection');
        const verbalUnitsSection = document.getElementById('verbalUnitsSection');
        const sentenceDisplaySection = document.getElementById('sentenceDisplaySection');
        const sentenceTextDisplay = document.getElementById('sentenceTextDisplay');
        const statusMessages = document.getElementById('statusMessages');

        fileInput.addEventListener('change', handleFileSelect);
        sentenceSelector.addEventListener('change', handleSentenceSelection);

        function displayError(message) {
            statusMessages.innerHTML = `<p class="error">${message}</p>`;
            console.error(message);
        }

        function displayStatus(message) {
            statusMessages.innerHTML = `<p>${message}</p>`;
            console.log(message);
        }

        function clearPreviousData() {
            parsedSentences = [];
            parsedVerbalUnits = [];
            parsedTokens = [];
            sentenceSelector.innerHTML = '<option value="">-- Load a file --</option>';
            selectedSentenceDisplay.textContent = '';
            verbalUnitsDisplayUl.innerHTML = '';
            sentenceTextDisplay.innerHTML = '';
            sentenceSection.style.display = 'none';
            verbalUnitsSection.style.display = 'none';
            sentenceDisplaySection.style.display = 'none';
            statusMessages.innerHTML = '';
        }

        function handleFileSelect(event) {
            clearPreviousData();
            const file = event.target.files[0];
            if (!file) {
                displayError('No file selected.');
                return;
            }

            displayStatus(`Loading ${file.name}...`);
            const parser = new CEXParser();
            parser.loadFromFile(file)
                .then(p => {
                    displayStatus('CEX data loaded! Processing...');
                    
                    const sentencesStr = p.getDelimitedData("sentences");
                    const verbalUnitsStr = p.getDelimitedData("verbal_units");
                    const tokensStr = p.getDelimitedData("tokens");

                    if (!sentencesStr || !verbalUnitsStr || !tokensStr) {
                        displayError('One or more required data blocks (sentences, verbal_units, tokens) are missing or empty in the CEX file.');
                        return;
                    }

                    const sentenceLines = sentencesStr.trim().split('\n');
                    parsedSentences = sentenceLines.length > 1 ? sentenceLines.slice(1) 
                        .map(line => {
                            const parts = line.split('|');
                            return { id: parts[0], sequence: parts[1], connector: parts[2] };
                        })
                        .filter(s => s.id && s.id.trim() !== "") : [];

                    const verbalUnitLines = verbalUnitsStr.trim().split('\n');
                    parsedVerbalUnits = verbalUnitLines.length > 1 ? verbalUnitLines.slice(1)
                        .map(line => {
                            const parts = line.split('|');
                            return { 
                                vuid: parts[0], 
                                syntactic_type: parts[1], 
                                semantic_type: parts[2], 
                                depth: parts[3], 
                                sentence: parts[4] 
                            };
                        })
                        .filter(vu => vu.vuid && vu.vuid.trim() !== "" && vu.sentence && vu.sentence.trim() !== "") : [];

                    const tokenLines = tokensStr.trim().split('\n');
                    parsedTokens = tokenLines.length > 1 ? tokenLines.slice(1)
                        .map(line => {
                            const parts = line.split('|');
                            return {
                                urn: parts[0],
                                reference: parts[1], 
                                tokentype: parts[2],
                                text: parts[3],
                                verbalunit: parts[4],
                                node1: parts[5],
                                node1relation: (parts[6] || "").trim(), // Ensure node1relation is trimmed
                                node2: parts[7],
                                node2relation: parts[8]
                            };
                        })
                        .filter(t => t.urn && t.urn.trim() !== "" && t.verbalunit && t.verbalunit.trim() !== "") : [];
                    
                    if (parsedVerbalUnits.length === 0) {
                        let errorMsg = 'No valid verbal units data found after excluding header. Cannot proceed.';
                        if (verbalUnitLines.length <=1 && verbalUnitsStr.trim() !== "") {
                            errorMsg = 'Verbal units data seems to only contain a header or is empty.';
                        }
                        displayError(errorMsg);
                        return;
                    }
                     if (parsedSentences.length === 0 && sentenceLines.length > 1) {
                        displayStatus('Warning: No valid sentence data found after excluding header, though a "sentences" block was present.');
                    }

                    populateSentenceSelector();
                    sentenceSection.style.display = 'block';
                    displayStatus(`Successfully processed ${file.name}. Select a sentence.`);
                })
                .catch(error => {
                    displayError(`Failed to load or parse CEX file: ${error.message}`);
                    console.error('Detailed error:', error);
                });
        }

        function populateSentenceSelector() {
            sentenceSelector.innerHTML = '<option value="">-- Select a Sentence --</option>'; 
            const sentenceIdsInVUs = new Set(parsedVerbalUnits.map(vu => vu.sentence));
            const allSentenceIdsFromSentencesBlock = new Set(parsedSentences.map(s => s.id));
            const displayableSentenceIds = [...allSentenceIdsFromSentencesBlock].filter(id => sentenceIdsInVUs.has(id));
            
            displayableSentenceIds.sort((a, b) => {
                const numA = parseInt(a.match(/\d+$/)?.[0] || a);
                const numB = parseInt(b.match(/\d+$/)?.[0] || b);
                if (!isNaN(numA) && !isNaN(numB)) return numA - numB;
                return a.localeCompare(b);
            });

            if (displayableSentenceIds.length === 0) {
                sentenceSelector.innerHTML = '<option value="">-- No sentences with verbal units --</option>';
                 if (parsedSentences.length > 0 && parsedVerbalUnits.length > 0) {
                    displayStatus('Info: While sentences and verbal units were loaded, no sentences from the "sentences" block are referenced in the "verbal_units" block, or vice-versa after filtering for valid data.');
                 } else if (parsedVerbalUnits.length > 0 && parsedSentences.length === 0) {
                     displayStatus('Info: Verbal units loaded, but the "sentences" block is missing, empty, or only contains a header. Cannot populate sentence menu.');
                 } else {
                    displayError('No sentences found that have associated verbal units. Check data integrity.');
                 }
                return;
            }
            displayableSentenceIds.forEach(sentenceId => {
                const option = document.createElement('option');
                option.value = sentenceId;
                option.textContent = sentenceId;
                sentenceSelector.appendChild(option);
            });
        }

        function handleSentenceSelection(event) {
            const selectedSentenceId = event.target.value;
            verbalUnitsDisplayUl.innerHTML = ''; 
            sentenceTextDisplay.innerHTML = '';
            verbalUnitsSection.style.display = 'none';
            sentenceDisplaySection.style.display = 'none';
            let localColorIndex = 0; 


            if (!selectedSentenceId) {
                selectedSentenceDisplay.textContent = '';
                return;
            }

            selectedSentenceDisplay.textContent = `Displaying data for sentence: ${selectedSentenceId}`;
            
            const VUsInSentence = parsedVerbalUnits
                .filter(vu => vu.sentence === selectedSentenceId)
                .map(vu_orig => {
                    const color = PASTEL_COLORS[localColorIndex % PASTEL_COLORS.length];
                    localColorIndex++;
                    return { ...vu_orig, displayColor: color }; 
                });

            if (VUsInSentence.length === 0) {
                verbalUnitsDisplayUl.innerHTML = '<li>No verbal units found for this sentence.</li>';
                verbalUnitsSection.style.display = 'block';
                sentenceDisplaySection.style.display = 'block';
                sentenceTextDisplay.innerHTML = '<em>No verbal units (and thus no tokens) for this sentence.</em>';
                return;
            }

            VUsInSentence.forEach(vu => {
                const tokensInThisVU = parsedTokens.filter(token => token.verbalunit === vu.vuid);
                const tokenCount = tokensInThisVU.length;

                const li = document.createElement('li');
                const syntacticSpan = document.createElement('span');
                syntacticSpan.classList.add('syntactic-type');
                syntacticSpan.style.backgroundColor = vu.displayColor; 
                syntacticSpan.textContent = vu.syntactic_type;

                li.appendChild(syntacticSpan);
                li.innerHTML += ` (${vu.semantic_type || 'N/A'}) - Tokens: ${tokenCount}`;
                verbalUnitsDisplayUl.appendChild(li);
            });
            verbalUnitsSection.style.display = 'block';

            const vuIdsInSentence = VUsInSentence.map(vu => vu.vuid);
            let sentenceTokens = parsedTokens.filter(token => vuIdsInSentence.includes(token.verbalunit));

            sentenceTokens.sort((a, b) => {
                const refA = parseInt(a.reference, 10);
                const refB = parseInt(b.reference, 10);
                if (isNaN(refA) && isNaN(refB)) return 0;
                if (isNaN(refA)) return 1; 
                if (isNaN(refB)) return -1;
                return refA - refB;
            });

            if (sentenceTokens.length > 0) {
                sentenceTokens.forEach(token => {
                    const tokenSpan = document.createElement('span');
                    tokenSpan.classList.add('token-span');
                    tokenSpan.textContent = token.text; 
                    
                    const parentVU = VUsInSentence.find(vu => vu.vuid === token.verbalunit);
                    if (parentVU && parentVU.displayColor) {
                        tokenSpan.style.backgroundColor = parentVU.displayColor;
                    } else {
                        tokenSpan.style.backgroundColor = '#eee'; 
                        tokenSpan.style.color = '#555';
                    }

                    // Apply decorations based on node1relation
                    if (token.node1relation === 'unit verb') {
                        tokenSpan.classList.add('token-unit-verb');
                    }
                    if (token.node1relation === 'subject') {
                        tokenSpan.classList.add('token-subject');
                    }
                    if (token.node1relation === 'direct object' || token.node1relation === 'predicate') {
                        tokenSpan.classList.add('token-direct-object-predicate');
                    }
                    
                    sentenceTextDisplay.appendChild(tokenSpan);
                    // Add a space after each token for better visual separation if not handled by margin/padding
                    // sentenceTextDisplay.appendChild(document.createTextNode(' ')); 
                });
            } else {
                sentenceTextDisplay.innerHTML = '<em>No tokens found associated with the verbal units of this sentence.</em>';
            }
            sentenceDisplaySection.style.display = 'block';
        }

    </script>
</body>
</html>
```

Key changes:

1.  **CSS (`<style>`):**
    *   Added styles for `.token-unit-verb`, `.token-subject`, and `.token-direct-object-predicate`.
    *   Slightly adjusted `padding` for `.token-span` and `line-height` for `#sentenceTextDisplay` to better accommodate the new decorations.
    *   Added `word-spacing` to `#sentenceTextDisplay` for a bit more visual separation between the token spans.

    ```css
    #sentenceTextDisplay {
        /* ... existing styles ... */
        line-height: 2.2; /* Increased line-height for readability of tokens & decorations */
        word-spacing: 2px; /* Add a bit more space between token-spans */
    }
    .token-span {
        padding: 3px 5px; /* Slightly more padding for decorations */
        /* ... existing styles ... */
        margin-bottom: 5px; /* For wrapped lines and decorations */
        position: relative; /* For potential future absolute positioning of complex decorations */
    }
    .token-unit-verb {
        border: 1.5px solid #444;
    }
    .token-subject {
        text-decoration: underline;
        text-decoration-color: #333;
        text-decoration-thickness: 1.5px;
    }
    .token-direct-object-predicate {
        text-decoration: underline overline;
        text-decoration-color: #333;
        text-decoration-thickness: 1.5px;
    }
    ```

2.  **JavaScript (`<script>`):**
    *   **Token Parsing:** In `handleFileSelect`, when parsing tokens, ensure `node1relation` is trimmed:
        ```javascript
        node1relation: (parts[6] || "").trim(), // Ensure node1relation is trimmed
        ```
    *   **`handleSentenceSelection()`:**
        *   Inside the `forEach` loop for `sentenceTokens`, after setting the background color:
            ```javascript
            // Apply decorations based on node1relation
            if (token.node1relation === 'unit verb') {
                tokenSpan.classList.add('token-unit-verb');
            }
            if (token.node1relation === 'subject') {
                tokenSpan.classList.add('token-subject');
            }
            if (token.node1relation === 'direct object' || token.node1relation === 'predicate') {
                tokenSpan.classList.add('token-direct-object-predicate');
            }
            ```
    *   Changed the H2 title for the sentence text display to reflect the new decorations:
        `<h2>Sentence Text (with token decorations):</h2>`

Now, when tokens are displayed:
*   Those with `node1relation` "unit verb" will have a box around them.
*   Those with `node1relation` "subject" will be underlined.
*   Those with `node1relation` "direct object" or "predicate" will have both an overline and an underline.
*   These decorations are in addition to the background color from their verbal unit.

### USER
Super. Let's add an additional further display. We'll use the `text` value of each token, and will create an indented display considering the context as follows: if a token belongs to the same verbal unit as the preceding token, it continues the display on the same line. If it belongs to a different verbal unit, it begins a new line. Line beginnings should be indented according to the depth value of the verbal unit. Level 1 verbal units should be flush left; level 2 units should be indented one level further; etc. Tokens on the same line should be separated by a single white space. Do not use a monospaced font: implement indentation with CSS. Please color and highlight each token as in the preceding display of the continuous sentence.

### ASSISTANT
Okay, this is a great way to visualize the hierarchical structure implied by verbal unit depth! We'll create a new display area for this.

Here's how we'll implement it:

1.  **HTML:**
    *   Add a new `div` section (e.g., `structuredDisplaySection`) with an `h2` and a `div` inside it (e.g., `structuredTokenDisplay`) to hold the indented lines of tokens.

2.  **CSS:**
    *   Add styles for the new `structuredTokenDisplay` container.
    *   Add a class for individual lines of tokens (e.g., `.structured-token-line`) that will primarily handle the `padding-left` for indentation.
    *   We will reuse the existing `.token-span` and its decoration classes (`.token-unit-verb`, etc.). I'll slightly adjust the `.token-span` to remove `margin-right` as we'll be adding explicit spaces.

3.  **JavaScript (`handleSentenceSelection`):**
    *   After processing verbal units and sorting `sentenceTokens`:
        *   Iterate through the `sentenceTokens`.
        *   Keep track of the current `verbalunit` ID.
        *   If the token's `verbalunit` is different from the previous one, create a new `div` (our line container).
            *   Calculate indentation: Retrieve the `depth` of the current token's verbal unit. Convert `depth` to an integer. Indentation will be `(depth - 1) * indent_amount_per_level`. Apply this as `padding-left` to the line container.
            *   Append this new line `div` to the `structuredTokenDisplay`.
        *   Create a `<span>` for the current token (reusing the coloring and decoration logic from the continuous sentence display).
        *   If the current line `div` already has tokens, append a space (as a text node) before adding the new token span.
        *   Append the token `span` to the current line `div`.
    *   Update `clearPreviousData` to also clear and hide this new display section.

Here's the complete updated HTML file:

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Greek Syntax Annotations Viewer</title>
    <script src="https://cdn.jsdelivr.net/gh/neelsmith/cex-lib/cex.js"></script>
    <style>
        body {
            font-family: sans-serif;
            margin: 20px;
            background-color: #f4f4f4;
            color: #333;
        }
        .container {
            background-color: #fff;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 0 10px rgba(0,0,0,0.1);
            margin-bottom: 30px; /* Space for content below */
        }
        h1, h2 {
            color: #555;
            margin-top: 20px;
        }
        h1:first-child, h2:first-child {
            margin-top: 0;
        }
        label {
            display: block;
            margin-top: 10px;
            margin-bottom: 5px;
            font-weight: bold;
        }
        select, input[type="file"] {
            padding: 8px;
            margin-bottom: 15px;
            border-radius: 4px;
            border: 1px solid #ccc;
            width: 100%;
            box-sizing: border-box;
        }
        #selectedSentenceDisplay {
            margin-top: 15px;
            padding: 10px;
            background-color: #e9e9e9;
            border-left: 5px solid #007bff;
            font-style: italic;
        }
        #verbalUnitsDisplay ul {
            list-style-type: none;
            padding: 0;
        }
        #verbalUnitsDisplay li {
            padding: 8px;
            border-bottom: 1px solid #eee;
            margin-bottom: 5px;
        }
        #verbalUnitsDisplay li:last-child {
            border-bottom: none;
        }
        .syntactic-type {
            padding: 2px 5px;
            border-radius: 3px;
            font-weight: bold;
            color: #000; /* Text color set to black */
        }

        /* Continuous Sentence Display */
        #sentenceTextDisplay {
            background-color: white;
            padding: 15px;
            margin-top: 10px;
            border: 1px solid #ddd;
            border-radius: 4px;
            line-height: 2.2; 
            word-spacing: 2px;
        }

        /* Structured Token Display */
        #structuredTokenDisplay {
            background-color: white; /* Keep consistent with other display */
            padding: 15px;
            margin-top: 10px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 1em; 
        }
        .structured-token-line {
            margin-bottom: 4px; /* Space between lines of VUs */
            line-height: 1.8; /* Adjust for readability within a line */
        }

        /* Common Token Span Styling */
        .token-span {
            padding: 3px 5px; 
            /* margin-right: 3px; Removed, as we'll add explicit spaces */
            margin-bottom: 5px; 
            display: inline-block; 
            border-radius: 3px;
            color: #000; 
            position: relative; 
        }
        .token-unit-verb {
            border: 1.5px solid #444;
        }
        .token-subject {
            text-decoration: underline;
            text-decoration-color: #333;
            text-decoration-thickness: 1.5px;
            text-underline-offset: 3px; /* Improve underline position */
        }
        .token-direct-object-predicate {
            text-decoration: underline overline;
            text-decoration-color: #333;
            text-decoration-thickness: 1.5px;
            text-underline-offset: 3px; /* Improve underline position */
        }
        .error {
            color: red;
            font-weight: bold;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Greek Syntax Data Loader</h1>

        <label for="fileInput">Choose a CEX file:</label>
        <input type="file" id="fileInput" accept=".cex">

        <div id="sentenceSection" style="display: none;">
            <label for="sentenceSelector">Select a Sentence:</label>
            <select id="sentenceSelector"></select>
            <div id="selectedSentenceDisplay"></div>
        </div>

        <div id="verbalUnitsSection" style="display: none;">
            <h2>Verbal Units in Selected Sentence:</h2>
            <div id="verbalUnitsDisplay">
                <ul></ul>
            </div>
        </div>

        <div id="sentenceDisplaySection" style="display: none;">
            <h2>Sentence Text (Continuous):</h2>
            <div id="sentenceTextDisplay"></div>
        </div>

        <div id="structuredDisplaySection" style="display: none;">
            <h2>Sentence Text (Structured by Verbal Unit Depth):</h2>
            <div id="structuredTokenDisplay"></div>
        </div>
        
        <div id="statusMessages"></div>
    </div>

    <script>
        let parsedSentences = [];
        let parsedVerbalUnits = [];
        let parsedTokens = [];

        const PASTEL_COLORS = [
            "#FFB3BA", "#FFDFBA", "#FFFFBA", "#BAFFC9", "#BAE1FF",
            "#E0BBE4", "#FFDAC1", "#B5EAD7", "#F9C7CF", "#C7CEEA"
        ];

        const fileInput = document.getElementById('fileInput');
        const sentenceSelector = document.getElementById('sentenceSelector');
        const selectedSentenceDisplay = document.getElementById('selectedSentenceDisplay');
        const verbalUnitsDisplayUl = document.querySelector('#verbalUnitsDisplay ul');
        const sentenceSection = document.getElementById('sentenceSection');
        const verbalUnitsSection = document.getElementById('verbalUnitsSection');
        
        const sentenceDisplaySection = document.getElementById('sentenceDisplaySection');
        const sentenceTextDisplay = document.getElementById('sentenceTextDisplay');
        
        const structuredDisplaySection = document.getElementById('structuredDisplaySection');
        const structuredTokenDisplay = document.getElementById('structuredTokenDisplay');
        
        const statusMessages = document.getElementById('statusMessages');

        fileInput.addEventListener('change', handleFileSelect);
        sentenceSelector.addEventListener('change', handleSentenceSelection);

        function displayError(message) {
            statusMessages.innerHTML = `<p class="error">${message}</p>`;
            console.error(message);
        }

        function displayStatus(message) {
            statusMessages.innerHTML = `<p>${message}</p>`;
            console.log(message);
        }

        function clearPreviousData() {
            parsedSentences = [];
            parsedVerbalUnits = [];
            parsedTokens = [];
            sentenceSelector.innerHTML = '<option value="">-- Load a file --</option>';
            selectedSentenceDisplay.textContent = '';
            verbalUnitsDisplayUl.innerHTML = '';
            sentenceTextDisplay.innerHTML = '';
            structuredTokenDisplay.innerHTML = ''; // Clear new display
            
            sentenceSection.style.display = 'none';
            verbalUnitsSection.style.display = 'none';
            sentenceDisplaySection.style.display = 'none';
            structuredDisplaySection.style.display = 'none'; // Hide new display
            statusMessages.innerHTML = '';
        }

        function handleFileSelect(event) {
            clearPreviousData();
            const file = event.target.files[0];
            if (!file) {
                displayError('No file selected.');
                return;
            }
            displayStatus(`Loading ${file.name}...`);
            const parser = new CEXParser();
            parser.loadFromFile(file)
                .then(p => {
                    displayStatus('CEX data loaded! Processing...');
                    const sentencesStr = p.getDelimitedData("sentences");
                    const verbalUnitsStr = p.getDelimitedData("verbal_units");
                    const tokensStr = p.getDelimitedData("tokens");

                    if (!sentencesStr || !verbalUnitsStr || !tokensStr) {
                        displayError('Required data blocks (sentences, verbal_units, tokens) missing.');
                        return;
                    }

                    const sentenceLines = sentencesStr.trim().split('\n');
                    parsedSentences = sentenceLines.length > 1 ? sentenceLines.slice(1) 
                        .map(line => ({ id: line.split('|')[0], sequence: line.split('|')[1], connector: line.split('|')[2] }))
                        .filter(s => s.id && s.id.trim() !== "") : [];

                    const verbalUnitLines = verbalUnitsStr.trim().split('\n');
                    parsedVerbalUnits = verbalUnitLines.length > 1 ? verbalUnitLines.slice(1)
                        .map(line => {
                            const parts = line.split('|');
                            return { vuid: parts[0], syntactic_type: parts[1], semantic_type: parts[2], depth: parts[3], sentence: parts[4] };
                        })
                        .filter(vu => vu.vuid && vu.vuid.trim() !== "" && vu.sentence && vu.sentence.trim() !== "") : [];

                    const tokenLines = tokensStr.trim().split('\n');
                    parsedTokens = tokenLines.length > 1 ? tokenLines.slice(1)
                        .map(line => {
                            const parts = line.split('|');
                            return {
                                urn: parts[0], reference: parts[1], tokentype: parts[2], text: parts[3],
                                verbalunit: parts[4], node1: parts[5], node1relation: (parts[6] || "").trim(),
                                node2: parts[7], node2relation: parts[8]
                            };
                        })
                        .filter(t => t.urn && t.urn.trim() !== "" && t.verbalunit && t.verbalunit.trim() !== "") : [];
                    
                    if (parsedVerbalUnits.length === 0) {
                        displayError(`No valid verbal units data. ${verbalUnitLines.length <=1 && verbalUnitsStr.trim() !== "" ? 'Block seems empty or header-only.' : ''}`);
                        return;
                    }
                    if (parsedSentences.length === 0 && sentenceLines.length > 1) {
                        displayStatus('Warning: No valid sentence data found (sentences block present but empty/header-only).');
                    }
                    populateSentenceSelector();
                    sentenceSection.style.display = 'block';
                    displayStatus(`Processed ${file.name}. Select a sentence.`);
                })
                .catch(error => {
                    displayError(`File load/parse error: ${error.message}`);
                    console.error('Detailed error:', error);
                });
        }

        function populateSentenceSelector() {
            sentenceSelector.innerHTML = '<option value="">-- Select a Sentence --</option>'; 
            const sentenceIdsInVUs = new Set(parsedVerbalUnits.map(vu => vu.sentence));
            const allSentenceIdsFromSentencesBlock = new Set(parsedSentences.map(s => s.id));
            const displayableSentenceIds = [...allSentenceIdsFromSentencesBlock].filter(id => sentenceIdsInVUs.has(id));
            
            displayableSentenceIds.sort((a, b) => {
                const numA = parseInt(a.match(/\d+$/)?.[0] || a);
                const numB = parseInt(b.match(/\d+$/)?.[0] || b);
                return (!isNaN(numA) && !isNaN(numB)) ? numA - numB : a.localeCompare(b);
            });

            if (displayableSentenceIds.length === 0) {
                sentenceSelector.innerHTML = '<option value="">-- No sentences with VUs --</option>';
                let infoMsg = 'No sentences with verbal units. ';
                if (parsedSentences.length > 0 && parsedVerbalUnits.length > 0) infoMsg += 'No overlap between "sentences" and "verbal_units" references.';
                else if (parsedVerbalUnits.length > 0 && parsedSentences.length === 0) infoMsg += '"sentences" block empty/missing.';
                displayStatus(`Info: ${infoMsg}`);
                return;
            }
            displayableSentenceIds.forEach(id => sentenceSelector.add(new Option(id, id)));
        }

        function _createTokenSpan(token, VUsInSentence) {
            const tokenSpan = document.createElement('span');
            tokenSpan.classList.add('token-span');
            tokenSpan.textContent = token.text;
            
            const parentVU = VUsInSentence.find(vu => vu.vuid === token.verbalunit);
            if (parentVU && parentVU.displayColor) {
                tokenSpan.style.backgroundColor = parentVU.displayColor;
            } else {
                tokenSpan.style.backgroundColor = '#eee'; 
                tokenSpan.style.color = '#555';
            }

            if (token.node1relation === 'unit verb') tokenSpan.classList.add('token-unit-verb');
            if (token.node1relation === 'subject') tokenSpan.classList.add('token-subject');
            if (token.node1relation === 'direct object' || token.node1relation === 'predicate') {
                tokenSpan.classList.add('token-direct-object-predicate');
            }
            return tokenSpan;
        }

        function handleSentenceSelection(event) {
            const selectedSentenceId = event.target.value;
            verbalUnitsDisplayUl.innerHTML = ''; 
            sentenceTextDisplay.innerHTML = '';
            structuredTokenDisplay.innerHTML = ''; // Clear new display
            
            verbalUnitsSection.style.display = 'none';
            sentenceDisplaySection.style.display = 'none';
            structuredDisplaySection.style.display = 'none'; // Hide new display
            
            let localColorIndex = 0; 

            if (!selectedSentenceId) {
                selectedSentenceDisplay.textContent = '';
                return;
            }

            selectedSentenceDisplay.textContent = `Displaying data for sentence: ${selectedSentenceId}`;
            
            const VUsInSentence = parsedVerbalUnits
                .filter(vu => vu.sentence === selectedSentenceId)
                .map(vu_orig => ({ ...vu_orig, displayColor: PASTEL_COLORS[localColorIndex++ % PASTEL_COLORS.length] }));

            if (VUsInSentence.length === 0) {
                verbalUnitsDisplayUl.innerHTML = '<li>No verbal units for this sentence.</li>';
                verbalUnitsSection.style.display = 'block';
                sentenceTextDisplay.innerHTML = '<em>No VUs, so no tokens.</em>';
                sentenceDisplaySection.style.display = 'block';
                structuredTokenDisplay.innerHTML = '<em>No VUs, so no tokens.</em>';
                structuredDisplaySection.style.display = 'block';
                return;
            }

            VUsInSentence.forEach(vu => {
                const tokenCount = parsedTokens.filter(t => t.verbalunit === vu.vuid).length;
                const li = document.createElement('li');
                const syntacticSpan = document.createElement('span');
                syntacticSpan.className = 'syntactic-type';
                syntacticSpan.style.backgroundColor = vu.displayColor; 
                syntacticSpan.textContent = vu.syntactic_type;
                li.appendChild(syntacticSpan);
                li.innerHTML += ` (${vu.semantic_type || 'N/A'}) - Tokens: ${tokenCount}`;
                verbalUnitsDisplayUl.appendChild(li);
            });
            verbalUnitsSection.style.display = 'block';

            const vuIdsInSentence = new Set(VUsInSentence.map(vu => vu.vuid));
            let sentenceTokens = parsedTokens
                .filter(token => vuIdsInSentence.has(token.verbalunit))
                .sort((a, b) => {
                    const refA = parseInt(a.reference, 10); const refB = parseInt(b.reference, 10);
                    if (isNaN(refA) && isNaN(refB)) return 0; if (isNaN(refA)) return 1; if (isNaN(refB)) return -1;
                    return refA - refB;
                });

            // Populate Continuous Sentence Display
            if (sentenceTokens.length > 0) {
                sentenceTokens.forEach(token => {
                    const tokenSpan = _createTokenSpan(token, VUsInSentence);
                    sentenceTextDisplay.appendChild(tokenSpan);
                    sentenceTextDisplay.appendChild(document.createTextNode(' ')); // Add space
                });
                // Remove last trailing space
                if (sentenceTextDisplay.lastChild && sentenceTextDisplay.lastChild.nodeType === Node.TEXT_NODE) {
                    sentenceTextDisplay.removeChild(sentenceTextDisplay.lastChild);
                }
            } else {
                sentenceTextDisplay.innerHTML = '<em>No tokens for VUs in this sentence.</em>';
            }
            sentenceDisplaySection.style.display = 'block';

            // Populate Structured Token Display
            if (sentenceTokens.length > 0) {
                let currentVUID = null;
                let currentLineDiv = null;
                const indentationUnitPx = 20; // 20px per indentation level

                sentenceTokens.forEach(token => {
                    if (token.verbalunit !== currentVUID) {
                        currentVUID = token.verbalunit;
                        currentLineDiv = document.createElement('div');
                        currentLineDiv.className = 'structured-token-line';

                        const parentVU = VUsInSentence.find(vu => vu.vuid === currentVUID);
                        if (parentVU) {
                            const depth = parseInt(parentVU.depth, 10) || 1; 
                            const indentLevel = Math.max(0, depth - 1); 
                            currentLineDiv.style.paddingLeft = `${indentLevel * indentationUnitPx}px`;
                        }
                        structuredTokenDisplay.appendChild(currentLineDiv);
                    }

                    const tokenSpan = _createTokenSpan(token, VUsInSentence);
                    
                    if (currentLineDiv) {
                        if (currentLineDiv.hasChildNodes()) { // Add space if not the first token on the line
                            currentLineDiv.appendChild(document.createTextNode(' '));
                        }
                        currentLineDiv.appendChild(tokenSpan);
                    }
                });
            } else {
                structuredTokenDisplay.innerHTML = '<em>No tokens for VUs in this sentence.</em>';
            }
            structuredDisplaySection.style.display = 'block';
        }
    </script>
</body>
</html>
```

Key changes and additions:

1.  **HTML (`<body>`):**
    *   Added the new section:
        ```html
        <div id="structuredDisplaySection" style="display: none;">
            <h2>Sentence Text (Structured by Verbal Unit Depth):</h2>
            <div id="structuredTokenDisplay"></div>
        </div>
        ```
    *   Renamed H2 for the continuous sentence display to "Sentence Text (Continuous):".

2.  **CSS (`<style>`):**
    *   Styles for `#structuredTokenDisplay` (container) and `.structured-token-line` (each line).
    *   Removed `margin-right` from `.token-span` as we're now adding explicit spaces via JavaScript.
    *   Added `text-underline-offset: 3px;` to `.token-subject` and `.token-direct-object-predicate` for better visual appearance of underlines, preventing them from clashing with descenders of letters.

3.  **JavaScript (`<script>`):**
    *   **Global Variables:** Added `structuredDisplaySection` and `structuredTokenDisplay` element references.
    *   **`clearPreviousData()`:** Added lines to clear `structuredTokenDisplay.innerHTML` and hide `structuredDisplaySection`.
    *   **Helper Function `_createTokenSpan(token, VUsInSentence)`:** Extracted the logic for creating and styling a token span (background color and decorations) into a reusable helper function. This reduces code duplication.
    *   **`handleSentenceSelection()`:**
        *   **Continuous Display:** Now uses `_createTokenSpan` and explicitly appends a space `document.createTextNode(' ')` after each token span. A check is added to remove the last trailing space.
        *   **Structured Display Logic:**
            *   Iterates through `sentenceTokens`.
            *   `currentVUID` tracks the verbal unit of the current line.
            *   When `token.verbalunit` changes:
                *   A new `div.structured-token-line` is created.
                *   The `depth` of the VU is fetched (defaulting to 1 if missing/invalid).
                *   `padding-left` is calculated: `(depth - 1) * indentationUnitPx`.
                *   The line `div` is appended to `structuredTokenDisplay`.
            *   The token `span` is created using `_createTokenSpan`.
            *   If the `currentLineDiv` is not empty, a space `document.createTextNode(' ')` is prepended.
            *   The token `span` is appended to `currentLineDiv`.
        *   Ensures both new display sections are shown.

This should give you the desired indented, structured view of tokens while maintaining all the previous styling and decorations.

### USER
Now one further display visualizing the syntax as a Mermaid visualization of a bottom-up directed graph. Relations among nodes are defined by  columns in the tokens table. `reference` identifies a node; use its `text` column as the label for the node with a given `reference` value.  Use `node1relation` as the label for an edge between `reference` and `node1`; use `node2relation` as the label for an edge between `reference` and `node2`.

### ASSISTANT
Okay, this will be a very informative visualization! We'll integrate the Mermaid.js library to render the directed graph.

Here's the plan:

1.  **HTML:**
    *   Add the Mermaid.js library script tag in the `<head>`.
    *   Add a new display section for the Mermaid graph, typically using a `<div>` with the class `mermaid`.
2.  **CSS:**
    *   Basic styling for the Mermaid container (e.g., to ensure it's visible, maybe a border).
3.  **JavaScript:**
    *   Initialize Mermaid.
    *   In `handleSentenceSelection`:
        *   After processing `sentenceTokens`:
            *   Create a set of all valid `reference` IDs present in the `sentenceTokens` of the selected sentence. This ensures we only draw edges to nodes that exist in the current graph.
            *   Construct the Mermaid graph definition string:
                *   Start with `graph BT;` for a bottom-up directed graph.
                *   Define nodes: For each token, use its `reference` as the node ID and its `text` as the label (e.g., `ref123["token text"]`).
                *   Define edges: For each token, if `node1` (and its `node1relation`) is valid and points to an existing node in the sentence, draw an edge: `node1_ref -- "node1relation text" --> current_token_ref`. Do similarly for `node2`.
            *   Use a helper function to escape special characters (like double quotes) in labels.
        *   Place this definition string into the Mermaid `div`.
        *   Tell Mermaid to render the graph in that `div`.
    *   Update `clearPreviousData` to also clear and hide this new Mermaid display section.

Here's the complete updated HTML file:

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Greek Syntax Annotations Viewer</title>
    <script src="https://cdn.jsdelivr.net/gh/neelsmith/cex-lib/cex.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.min.js"></script>
    <style>
        body {
            font-family: sans-serif;
            margin: 20px;
            background-color: #f4f4f4;
            color: #333;
        }
        .container {
            background-color: #fff;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 0 10px rgba(0,0,0,0.1);
            margin-bottom: 30px; 
        }
        h1, h2 {
            color: #555;
            margin-top: 20px;
        }
        h1:first-child, h2:first-child {
            margin-top: 0;
        }
        label {
            display: block;
            margin-top: 10px;
            margin-bottom: 5px;
            font-weight: bold;
        }
        select, input[type="file"] {
            padding: 8px;
            margin-bottom: 15px;
            border-radius: 4px;
            border: 1px solid #ccc;
            width: 100%;
            box-sizing: border-box;
        }
        #selectedSentenceDisplay {
            margin-top: 15px;
            padding: 10px;
            background-color: #e9e9e9;
            border-left: 5px solid #007bff;
            font-style: italic;
        }
        #verbalUnitsDisplay ul {
            list-style-type: none;
            padding: 0;
        }
        #verbalUnitsDisplay li {
            padding: 8px;
            border-bottom: 1px solid #eee;
            margin-bottom: 5px;
        }
        #verbalUnitsDisplay li:last-child {
            border-bottom: none;
        }
        .syntactic-type {
            padding: 2px 5px;
            border-radius: 3px;
            font-weight: bold;
            color: #000;
        }
        #sentenceTextDisplay, #structuredTokenDisplay, #mermaidGraphContainer {
            background-color: white;
            padding: 15px;
            margin-top: 10px;
            border: 1px solid #ddd;
            border-radius: 4px;
        }
        #sentenceTextDisplay {
            line-height: 2.2; 
            word-spacing: 2px;
        }
        #structuredTokenDisplay {
            font-size: 1em; 
        }
        .structured-token-line {
            margin-bottom: 4px; 
            line-height: 1.8; 
        }
        .token-span {
            padding: 3px 5px; 
            margin-bottom: 5px; 
            display: inline-block; 
            border-radius: 3px;
            color: #000; 
            position: relative; 
        }
        .token-unit-verb { border: 1.5px solid #444; }
        .token-subject {
            text-decoration: underline;
            text-decoration-color: #333;
            text-decoration-thickness: 1.5px;
            text-underline-offset: 3px;
        }
        .token-direct-object-predicate {
            text-decoration: underline overline;
            text-decoration-color: #333;
            text-decoration-thickness: 1.5px;
            text-underline-offset: 3px;
        }
        #mermaidGraphContainer svg { /* Ensure SVG scales nicely */
            max-width: 100%;
            height: auto;
        }
        .error { color: red; font-weight: bold; }
    </style>
</head>
<body>
    <div class="container">
        <h1>Greek Syntax Data Loader</h1>
        <label for="fileInput">Choose a CEX file:</label>
        <input type="file" id="fileInput" accept=".cex">

        <div id="sentenceSection" style="display: none;">
            <label for="sentenceSelector">Select a Sentence:</label>
            <select id="sentenceSelector"></select>
            <div id="selectedSentenceDisplay"></div>
        </div>

        <div id="verbalUnitsSection" style="display: none;">
            <h2>Verbal Units in Selected Sentence:</h2>
            <div id="verbalUnitsDisplay"><ul></ul></div>
        </div>

        <div id="sentenceDisplaySection" style="display: none;">
            <h2>Sentence Text (Continuous):</h2>
            <div id="sentenceTextDisplay"></div>
        </div>

        <div id="structuredDisplaySection" style="display: none;">
            <h2>Sentence Text (Structured by Verbal Unit Depth):</h2>
            <div id="structuredTokenDisplay"></div>
        </div>

        <div id="mermaidDisplaySection" style="display: none;">
            <h2>Syntax Graph (Mermaid):</h2>
            <div id="mermaidGraphContainer" class="mermaid">
                <!-- Mermaid graph will be rendered here by script -->
            </div>
        </div>
        
        <div id="statusMessages"></div>
    </div>

    <script>
        mermaid.initialize({ startOnLoad: false, securityLevel: 'loose' }); // Initialize Mermaid

        let parsedSentences = [];
        let parsedVerbalUnits = [];
        let parsedTokens = [];

        const PASTEL_COLORS = ["#FFB3BA", "#FFDFBA", "#FFFFBA", "#BAFFC9", "#BAE1FF", "#E0BBE4", "#FFDAC1", "#B5EAD7", "#F9C7CF", "#C7CEEA"];

        const fileInput = document.getElementById('fileInput');
        const sentenceSelector = document.getElementById('sentenceSelector');
        const selectedSentenceDisplay = document.getElementById('selectedSentenceDisplay');
        const verbalUnitsDisplayUl = document.querySelector('#verbalUnitsDisplay ul');
        const sentenceSection = document.getElementById('sentenceSection');
        const verbalUnitsSection = document.getElementById('verbalUnitsSection');
        const sentenceDisplaySection = document.getElementById('sentenceDisplaySection');
        const sentenceTextDisplay = document.getElementById('sentenceTextDisplay');
        const structuredDisplaySection = document.getElementById('structuredDisplaySection');
        const structuredTokenDisplay = document.getElementById('structuredTokenDisplay');
        const mermaidDisplaySection = document.getElementById('mermaidDisplaySection');
        const mermaidGraphContainer = document.getElementById('mermaidGraphContainer');
        const statusMessages = document.getElementById('statusMessages');

        fileInput.addEventListener('change', handleFileSelect);
        sentenceSelector.addEventListener('change', handleSentenceSelection);

        function displayError(message) {
            statusMessages.innerHTML = `<p class="error">${message}</p>`; console.error(message);
        }
        function displayStatus(message) {
            statusMessages.innerHTML = `<p>${message}</p>`; console.log(message);
        }

        function clearPreviousData() {
            parsedSentences = []; parsedVerbalUnits = []; parsedTokens = [];
            sentenceSelector.innerHTML = '<option value="">-- Load a file --</option>';
            selectedSentenceDisplay.textContent = '';
            verbalUnitsDisplayUl.innerHTML = '';
            sentenceTextDisplay.innerHTML = '';
            structuredTokenDisplay.innerHTML = '';
            mermaidGraphContainer.innerHTML = ''; // Clear Mermaid content
            mermaidGraphContainer.removeAttribute('data-processed'); // For Mermaid re-rendering

            sentenceSection.style.display = 'none';
            verbalUnitsSection.style.display = 'none';
            sentenceDisplaySection.style.display = 'none';
            structuredDisplaySection.style.display = 'none';
            mermaidDisplaySection.style.display = 'none'; // Hide Mermaid section
            statusMessages.innerHTML = '';
        }

        function handleFileSelect(event) {
            clearPreviousData();
            const file = event.target.files[0];
            if (!file) { displayError('No file selected.'); return; }
            displayStatus(`Loading ${file.name}...`);
            const parser = new CEXParser();
            parser.loadFromFile(file)
                .then(p => {
                    displayStatus('CEX data loaded! Processing...');
                    const sentencesStr = p.getDelimitedData("sentences");
                    const verbalUnitsStr = p.getDelimitedData("verbal_units");
                    const tokensStr = p.getDelimitedData("tokens");

                    if (!sentencesStr || !verbalUnitsStr || !tokensStr) {
                        displayError('Required data blocks missing.'); return;
                    }

                    const sLines = sentencesStr.trim().split('\n');
                    parsedSentences = sLines.length > 1 ? sLines.slice(1).map(l => ({ id: l.split('|')[0], s: l.split('|')[1], c: l.split('|')[2] })).filter(s => s.id && s.id.trim()) : [];
                    const vuLines = verbalUnitsStr.trim().split('\n');
                    parsedVerbalUnits = vuLines.length > 1 ? vuLines.slice(1).map(l => { const ps = l.split('|'); return { vuid: ps[0], st: ps[1], sem: ps[2], depth: ps[3], sent: ps[4] }; }).filter(vu => vu.vuid && vu.vuid.trim() && vu.sent && vu.sent.trim()) : [];
                    const tLines = tokensStr.trim().split('\n');
                    parsedTokens = tLines.length > 1 ? tLines.slice(1).map(l => { const ps = l.split('|'); return { u: ps[0], ref: ps[1], tt: ps[2], txt: ps[3], vu: ps[4], n1: ps[5], n1r: (ps[6] || "").trim(), n2: ps[7], n2r: (ps[8] || "").trim() }; }).filter(t => t.u && t.u.trim() && t.vu && t.vu.trim()) : [];
                    
                    if (parsedVerbalUnits.length === 0) { displayError(`No valid VUs. ${vuLines.length <=1 && verbalUnitsStr.trim() ? 'Block empty/header.' : ''}`); return; }
                    if (parsedSentences.length === 0 && sLines.length > 1) displayStatus('Warning: Sentences block empty/header.');
                    
                    populateSentenceSelector();
                    sentenceSection.style.display = 'block';
                    displayStatus(`Processed ${file.name}. Select sentence.`);
                })
                .catch(e => { displayError(`File error: ${e.message}`); console.error('Err:', e); });
        }

        function populateSentenceSelector() {
            sentenceSelector.innerHTML = '<option value="">-- Select --</option>'; 
            const vuSents = new Set(parsedVerbalUnits.map(vu => vu.sent));
            const sIds = new Set(parsedSentences.map(s => s.id));
            const dispIds = [...sIds].filter(id => vuSents.has(id)).sort((a, b) => { const nA=parseInt(a.match(/\d+$/)?.[0]||a),nB=parseInt(b.match(/\d+$/)?.[0]||b); return (!isNaN(nA)&&!isNaN(nB))?nA-nB:a.localeCompare(b);});
            if (dispIds.length===0) { sentenceSelector.innerHTML='<option value="">-- No Sents w/VUs --</option>'; displayStatus('Info: No sentences found with VUs.'); return; }
            dispIds.forEach(id => sentenceSelector.add(new Option(id, id)));
        }

        function escapeMermaidLabel(text) {
            if (!text) return "";
            return text.replace(/"/g, '#quot;'); // Mermaid specific escape for double quotes
        }

        function _createTokenSpan(token, VUsInSentence) {
            const span = document.createElement('span');
            span.className = 'token-span'; span.textContent = token.txt;
            const vu = VUsInSentence.find(v => v.vuid === token.vu);
            if (vu && vu.dispClr) span.style.backgroundColor = vu.dispClr; else { span.style.backgroundColor = '#eee'; span.style.color = '#555'; }
            if (token.n1r === 'unit verb') span.classList.add('token-unit-verb');
            if (token.n1r === 'subject') span.classList.add('token-subject');
            if (token.n1r === 'direct object' || token.n1r === 'predicate') span.classList.add('token-direct-object-predicate');
            return span;
        }

        async function handleSentenceSelection(event) { // Made async for Mermaid rendering
            const selSentId = event.target.value;
            verbalUnitsDisplayUl.innerHTML = ''; sentenceTextDisplay.innerHTML = ''; structuredTokenDisplay.innerHTML = '';
            mermaidGraphContainer.innerHTML = ''; mermaidGraphContainer.removeAttribute('data-processed');

            ['verbalUnitsSection', 'sentenceDisplaySection', 'structuredDisplaySection', 'mermaidDisplaySection'].forEach(s => document.getElementById(s).style.display = 'none');
            
            let locClrIdx = 0; 
            if (!selSentId) { selectedSentenceDisplay.textContent = ''; return; }
            selectedSentenceDisplay.textContent = `Data for sentence: ${selSentId}`;
            
            const VUsInSent = parsedVerbalUnits.filter(vu => vu.sent === selSentId).map(vo => ({ ...vo, dispClr: PASTEL_COLORS[locClrIdx++ % PASTEL_COLORS.length] }));
            if (VUsInSent.length === 0) {
                ['verbalUnitsDisplayUl', 'sentenceTextDisplay', 'structuredTokenDisplay', 'mermaidGraphContainer'].forEach(elId => {
                    const el = document.getElementById(elId) || document.querySelector(`#${elId} ul`);
                    if(el) el.innerHTML = elId === 'verbalUnitsDisplayUl' ? '<li>No VUs.</li>' : '<em>No VUs, so no tokens.</em>';
                });
                ['verbalUnitsSection', 'sentenceDisplaySection', 'structuredDisplaySection', 'mermaidDisplaySection'].forEach(s => document.getElementById(s).style.display = 'block');
                return;
            }

            VUsInSent.forEach(vu => {
                const tc = parsedTokens.filter(t => t.vu === vu.vuid).length;
                const li = document.createElement('li'); const ss = document.createElement('span');
                ss.className = 'syntactic-type'; ss.style.backgroundColor = vu.dispClr; ss.textContent = vu.st;
                li.appendChild(ss); li.innerHTML += ` (${vu.sem || 'N/A'}) - Tokens: ${tc}`;
                verbalUnitsDisplayUl.appendChild(li);
            });
            verbalUnitsSection.style.display = 'block';

            const vuIdsInSent = new Set(VUsInSent.map(vu => vu.vuid));
            let sentToks = parsedTokens.filter(t => vuIdsInSent.has(t.vu)).sort((a,b)=>{ const rA=parseInt(a.ref,10),rB=parseInt(b.ref,10); if(isNaN(rA)&&isNaN(rB))return 0; if(isNaN(rA))return 1; if(isNaN(rB))return -1; return rA-rB;});

            // Continuous Sentence Display
            if (sentToks.length > 0) {
                sentToks.forEach(t => { sentenceTextDisplay.appendChild(_createTokenSpan(t, VUsInSent)); sentenceTextDisplay.appendChild(document.createTextNode(' ')); });
                if (sentenceTextDisplay.lastChild) sentenceTextDisplay.removeChild(sentenceTextDisplay.lastChild);
            } else sentenceTextDisplay.innerHTML = '<em>No tokens.</em>';
            sentenceDisplaySection.style.display = 'block';

            // Structured Token Display
            if (sentToks.length > 0) {
                let curVUID = null, curLineDiv = null; const indentPx = 20;
                sentToks.forEach(t => {
                    if (t.vu !== curVUID) {
                        curVUID = t.vu; curLineDiv = document.createElement('div'); curLineDiv.className = 'structured-token-line';
                        const pVU = VUsInSent.find(v => v.vuid === curVUID);
                        if (pVU) { const d = parseInt(pVU.depth,10)||1; curLineDiv.style.paddingLeft = `${Math.max(0,d-1)*indentPx}px`; }
                        structuredTokenDisplay.appendChild(curLineDiv);
                    }
                    if (curLineDiv) { if (curLineDiv.hasChildNodes()) curLineDiv.appendChild(document.createTextNode(' ')); curLineDiv.appendChild(_createTokenSpan(t, VUsInSent)); }
                });
            } else structuredTokenDisplay.innerHTML = '<em>No tokens.</em>';
            structuredDisplaySection.style.display = 'block';

            // Mermaid Graph Display
            if (sentToks.length > 0) {
                const mermaidDef = ['graph BT;']; // Bottom-Up graph
                const validNodeRefs = new Set(sentToks.map(t => t.ref));

                // Define nodes
                sentToks.forEach(t => {
                    mermaidDef.push(`${t.ref}["${escapeMermaidLabel(t.txt)}"];`);
                });

                // Define edges
                sentToks.forEach(t => {
                    if (t.n1 && validNodeRefs.has(t.n1) && t.n1r) {
                        mermaidDef.push(`${t.n1} -- "${escapeMermaidLabel(t.n1r)}" --> ${t.ref};`);
                    }
                    if (t.n2 && validNodeRefs.has(t.n2) && t.n2r) {
                        mermaidDef.push(`${t.n2} -- "${escapeMermaidLabel(t.n2r)}" --> ${t.ref};`);
                    }
                });
                
                const mermaidString = mermaidDef.join('\n');
                // mermaidGraphContainer.textContent = mermaidString; // For raw display
                // mermaidGraphContainer.removeAttribute('data-processed'); // Ensure re-processing
                // mermaid.run({nodes: [mermaidGraphContainer]}); // Render

                // Using mermaid.render for more control and async behavior
                try {
                    const { svg, bindFunctions } = await mermaid.render('mermaid-graph-' + Date.now(), mermaidString);
                    mermaidGraphContainer.innerHTML = svg;
                    if (bindFunctions) bindFunctions(mermaidGraphContainer);
                } catch (e) {
                    mermaidGraphContainer.innerHTML = `<p class="error">Error rendering Mermaid graph: ${e.message}</p><pre>${mermaidString}</pre>`;
                    console.error("Mermaid rendering error:", e, "\nGraph definition:\n", mermaidString);
                }

            } else {
                mermaidGraphContainer.innerHTML = '<em>No tokens to graph.</em>';
            }
            mermaidDisplaySection.style.display = 'block';
        }
    </script>
</body>
</html>
```

Key Changes:

1.  **HTML (`<head>`):**
    *   Added Mermaid.js: `<script src="https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.min.js"></script>`.
2.  **HTML (`<body>`):**
    *   Added the Mermaid display section:
        ```html
        <div id="mermaidDisplaySection" style="display: none;">
            <h2>Syntax Graph (Mermaid):</h2>
            <div id="mermaidGraphContainer" class="mermaid">
                <!-- Mermaid graph will be rendered here by script -->
            </div>
        </div>
        ```
    *   Note: I've added `class="mermaid"` to `mermaidGraphContainer` as it's often how Mermaid identifies elements, though we'll use targeted rendering.
3.  **CSS (`<style>`):**
    *   Added basic styling for `#mermaidGraphContainer` and its SVG content to ensure it displays reasonably.
        ```css
        #mermaidGraphContainer svg { /* Ensure SVG scales nicely */
            max-width: 100%;
            height: auto;
        }
        ```
4.  **JavaScript (`<script>`):**
    *   **Mermaid Initialization:** `mermaid.initialize({ startOnLoad: false, securityLevel: 'loose' });` is called at the top of the script block. `securityLevel: 'loose'` is often helpful for dynamic content, though for simple labels, stricter levels might work.
    *   **Global Variables:** Added `mermaidDisplaySection` and `mermaidGraphContainer`.
    *   **`clearPreviousData()`:**
        *   Clears `mermaidGraphContainer.innerHTML`.
        *   Removes `data-processed` attribute (important for some Mermaid re-rendering strategies, though `mermaid.render` might not need it).
        *   Hides `mermaidDisplaySection`.
    *   **`escapeMermaidLabel(text)` function:** Added to escape double quotes within labels using Mermaid's `#quot;` syntax.
    *   **Column Name Shortening in Parsing (Minor internal change for brevity):**
        *   When parsing tokens and VUs, I used shorter internal keys (e.g., `txt` for `text`, `ref` for `reference`, `n1r` for `node1relation`). This is just an internal detail and doesn't change the logic related to the original CEX column names. This was done to make the lines a bit shorter while working. The logic for accessing these (e.g., `token.txt`, `token.n1r`) is consistent.
    *   **`handleSentenceSelection()`:**
        *   Made the function `async` to use `await mermaid.render()`.
        *   **Graph Definition:**
            *   `mermaidDef = ['graph BT;']` initializes lines for the graph definition.
            *   `validNodeRefs = new Set(sentToks.map(t => t.ref))` creates a set of all token references in the current sentence.
            *   Nodes are defined: `mermaidDef.push(`${t.ref}["${escapeMermaidLabel(t.txt)}"];`);`.
            *   Edges are defined, checking if `t.n1` (node1's reference) and `t.n2` are in `validNodeRefs`:
                ```javascript
                if (t.n1 && validNodeRefs.has(t.n1) && t.n1r) {
                    mermaidDef.push(`${t.n1} -- "${escapeMermaidLabel(t.n1r)}" --> ${t.ref};`);
                }
                // Similar for t.n2
                ```
        *   **Mermaid Rendering:**
            *   The `mermaidString` is joined.
            *   The `mermaid.render()` API is used:
                ```javascript
                try {
                    const { svg, bindFunctions } = await mermaid.render('mermaid-graph-' + Date.now(), mermaidString); // Unique ID for render call
                    mermaidGraphContainer.innerHTML = svg;
                    if (bindFunctions) bindFunctions(mermaidGraphContainer);
                } catch (e) {
                    mermaidGraphContainer.innerHTML = `<p class="error">Error rendering Mermaid graph: ${e.message}</p><pre>${mermaidString}</pre>`;
                    console.error("Mermaid rendering error:", e, "\nGraph definition:\n", mermaidString);
                }
                ```
            *   This is generally the recommended way for dynamic rendering with newer Mermaid versions. It renders to an SVG string which is then injected.
        *   The `mermaidDisplaySection` is shown.

This setup should now generate and display a bottom-up directed graph for the selected sentence's tokens and their specified relationships.

### USER
Gorgeous! That's all the key functionality! Now tweaking the display:  I would like to put each of the two sections labelled "Sentence Text (Structured by Verbal Unit Depth):" and "Syntax Graph (Mermaid): in foldable sections, so that the Verbal Units section would _always_ be displayed, but the user could show or hide the "Structured Layout" and "Syntax Graph" sections. Immediately above the "Sentence Text (Continuous):" I'd like to add a further collapsible section, titled "Key". Its header should be smaller than the other sections. The conents of the seciton should list three pieces of information, namely:
  
- _boxes_ == verb forms
- _underscore_ == subject of verb
- _underscore + overline_ == direct object

### ASSISTANT
Okay, this will make the UI much cleaner and more user-controllable! We'll use the HTML `<details>` and `<summary>` elements for the collapsible sections.

Here's how we'll adjust the HTML, CSS, and JavaScript:

1.  **HTML Structure Changes:**
    *   **New "Key" Section:**
        *   Introduce a new `div` (e.g., `keySection`) to be shown/hidden like other main sections.
        *   Inside it, use `<details open>` (so it's open by default).
        *   The `<summary>` will contain an `<h3>Key</h3>`.
        *   The content will be a `<ul>` listing the decoration meanings.
    *   **Structured Layout Section:**
        *   The existing `div#structuredDisplaySection` will now contain a `<details>` element.
        *   The `<h2>Sentence Text (Structured by Verbal Unit Depth):</h2>` will move inside the `<summary>` of this `<details>` element.
        *   The `div#structuredTokenDisplay` will be the content of this `<details>` element.
    *   **Mermaid Graph Section:**
        *   Similar to the structured layout, `div#mermaidDisplaySection` will contain a `<details>` element.
        *   The `<h2>Syntax Graph (Mermaid):</h2>` will move into its `<summary>`.
        *   The `div#mermaidGraphContainer` will be the content.

2.  **CSS Styling:**
    *   Style `<summary>` elements to act as clickable headers.
    *   Adjust styling for the `<h3>` inside the "Key" section's summary.
    *   Ensure proper spacing and layout for the `<details>` elements.

3.  **JavaScript Changes:**
    *   **`clearPreviousData()`:** Will also need to ensure the new "Key" section's container is hidden.
    *   **`handleFileSelect()` / `handleSentenceSelection()`:** The logic for showing the main container `div`s (like `structuredDisplaySection`, `mermaidDisplaySection`) will remain. The `<details>` element within them will control the expand/collapse state of the actual content.
    *   The "Key" section's content is static, so it just needs its container `div` to be shown when data is loaded and a sentence is ready to be analyzed.

Here's the updated complete HTML file:

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Greek Syntax Annotations Viewer</title>
    <script src="https://cdn.jsdelivr.net/gh/neelsmith/cex-lib/cex.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.min.js"></script>
    <style>
        body {
            font-family: sans-serif;
            margin: 20px;
            background-color: #f4f4f4;
            color: #333;
        }
        .container {
            background-color: #fff;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 0 10px rgba(0,0,0,0.1);
            margin-bottom: 30px; 
        }
        h1, h2 { /* Base for main section titles */
            color: #555;
            margin-top: 25px; /* More space before main sections */
            margin-bottom: 10px;
        }
        h1:first-child, h2:first-child {
            margin-top: 0;
        }
        label {
            display: block;
            margin-top: 10px;
            margin-bottom: 5px;
            font-weight: bold;
        }
        select, input[type="file"] {
            padding: 8px;
            margin-bottom: 15px;
            border-radius: 4px;
            border: 1px solid #ccc;
            width: 100%;
            box-sizing: border-box;
        }
        #selectedSentenceDisplay {
            margin-top: 15px;
            padding: 10px;
            background-color: #e9e9e9;
            border-left: 5px solid #007bff;
            font-style: italic;
            margin-bottom: 20px;
        }

        /* Collapsible Section Styling */
        details {
            border: 1px solid #ddd;
            border-radius: 4px;
            margin-bottom: 15px;
            background-color: #fff; /* Give details a background for content */
        }
        details[open] {
            /* Optional: slightly more emphasis when open */
        }
        summary {
            padding: 10px 15px;
            background-color: #f9f9f9;
            border-bottom: 1px solid #ddd; /* Separator for summary */
            cursor: pointer;
            list-style: none; /* Remove default marker */
            font-weight: bold;
            color: #444;
        }
        summary::-webkit-details-marker { display: none; } /* Chrome/Safari */
        summary::marker { display: none; } /* Firefox */
        summary:hover { background-color: #f0f0f0; }
        
        details summary h2, details summary h3 {
            display: inline; /* Keep marker (if any) or custom arrow on same line */
            margin: 0;
            font-size: 1.2em; /* Default for h2 in summary */
            color: #555;
        }
        /* Key section specific header */
        #keySection details summary h3 {
            font-size: 1.0em; /* Smaller header for "Key" */
            font-weight: bold;
            color: #666;
        }
        .details-content {
            padding: 15px;
        }
        #keySection .details-content ul {
            padding-left: 20px;
            margin-top: 5px;
            margin-bottom: 5px;
        }
        #keySection .details-content li {
            margin-bottom: 3px;
        }


        #verbalUnitsDisplay ul {
            list-style-type: none;
            padding: 0;
            background-color: white; /* Ensure VU list has white BG */
            border: 1px solid #ddd;
            border-radius: 4px;
            padding:10px;
        }
        #verbalUnitsDisplay li {
            padding: 8px;
            border-bottom: 1px solid #eee;
            margin-bottom: 5px;
        }
        #verbalUnitsDisplay li:last-child {
            border-bottom: none;
        }
        .syntactic-type {
            padding: 2px 5px;
            border-radius: 3px;
            font-weight: bold;
            color: #000;
        }
        #sentenceTextDisplay, #structuredTokenDisplay, #mermaidGraphContainer {
            /* These are now inside .details-content, so direct background/padding might not be needed
               unless .details-content doesn't provide it */
        }
        #sentenceTextDisplay {
            line-height: 2.2; 
            word-spacing: 2px;
        }
        #structuredTokenDisplay {
            font-size: 1em; 
        }
        .structured-token-line {
            margin-bottom: 4px; 
            line-height: 1.8; 
        }
        .token-span {
            padding: 3px 5px; 
            margin-bottom: 5px; 
            display: inline-block; 
            border-radius: 3px;
            color: #000; 
            position: relative; 
        }
        .token-unit-verb { border: 1.5px solid #444; }
        .token-subject {
            text-decoration: underline;
            text-decoration-color: #333;
            text-decoration-thickness: 1.5px;
            text-underline-offset: 3px;
        }
        .token-direct-object-predicate {
            text-decoration: underline overline;
            text-decoration-color: #333;
            text-decoration-thickness: 1.5px;
            text-underline-offset: 3px;
        }
        #mermaidGraphContainer svg { 
            max-width: 100%;
            height: auto;
        }
        .error { color: red; font-weight: bold; }
    </style>
</head>
<body>
    <div class="container">
        <h1>Greek Syntax Data Loader</h1>
        <label for="fileInput">Choose a CEX file:</label>
        <input type="file" id="fileInput" accept=".cex">

        <div id="sentenceSection" style="display: none;">
            <label for="sentenceSelector">Select a Sentence:</label>
            <select id="sentenceSelector"></select>
            <div id="selectedSentenceDisplay"></div>
        </div>

        <!-- Key Section - Collapsible, Open by Default -->
        <div id="keySection" style="display: none;">
            <details open>
                <summary><h3>Key</h3></summary>
                <div class="details-content">
                    <ul>
                        <li><strong>Boxes:</strong> verb forms (token with <code>node1relation</code> = "unit verb")</li>
                        <li><strong>Underscore:</strong> subject of verb (token with <code>node1relation</code> = "subject")</li>
                        <li><strong>Underscore + Overline:</strong> direct object or predicate (token with <code>node1relation</code> = "direct object" or "predicate")</li>
                    </ul>
                </div>
            </details>
        </div>

        <!-- Sentence Text (Continuous) - Always Visible Content Area when data is loaded -->
        <div id="sentenceDisplaySection" style="display: none;">
            <h2>Sentence Text (Continuous):</h2>
            <div id="sentenceTextDisplay" class="details-content"> <!-- Re-using .details-content for padding -->
                <!-- Tokens will be rendered here -->
            </div>
        </div>

        <!-- Verbal Units Section - Always Visible Content Area when data is loaded -->
        <div id="verbalUnitsSection" style="display: none;">
            <h2>Verbal Units in Selected Sentence:</h2>
            <div id="verbalUnitsDisplay"><ul></ul></div>
        </div>

        <!-- Structured Layout - Collapsible -->
        <div id="structuredDisplaySection" style="display: none;">
            <details>
                <summary><h2>Sentence Text (Structured by Verbal Unit Depth)</h2></summary>
                <div id="structuredTokenDisplay" class="details-content">
                    <!-- Structured tokens will be rendered here -->
                </div>
            </details>
        </div>

        <!-- Mermaid Graph - Collapsible -->
        <div id="mermaidDisplaySection" style="display: none;">
            <details>
                <summary><h2>Syntax Graph (Mermaid)</h2></summary>
                <div id="mermaidGraphContainer" class="mermaid details-content">
                    <!-- Mermaid graph will be rendered here -->
                </div>
            </details>
        </div>
        
        <div id="statusMessages"></div>
    </div>

    <script>
        mermaid.initialize({ startOnLoad: false, securityLevel: 'loose' });

        let parsedSentences = [], parsedVerbalUnits = [], parsedTokens = [];
        const PASTEL_COLORS = ["#FFB3BA", "#FFDFBA", "#FFFFBA", "#BAFFC9", "#BAE1FF", "#E0BBE4", "#FFDAC1", "#B5EAD7", "#F9C7CF", "#C7CEEA"];

        const fileInput = document.getElementById('fileInput');
        const sentenceSelector = document.getElementById('sentenceSelector');
        const selectedSentenceDisplay = document.getElementById('selectedSentenceDisplay');
        const verbalUnitsDisplayUl = document.querySelector('#verbalUnitsDisplay ul');
        
        const sentenceSection = document.getElementById('sentenceSection');
        const keySection = document.getElementById('keySection'); // New
        const sentenceDisplaySection = document.getElementById('sentenceDisplaySection');
        const verbalUnitsSection = document.getElementById('verbalUnitsSection');
        const structuredDisplaySection = document.getElementById('structuredDisplaySection');
        const mermaidDisplaySection = document.getElementById('mermaidDisplaySection');
        
        const sentenceTextDisplay = document.getElementById('sentenceTextDisplay');
        const structuredTokenDisplay = document.getElementById('structuredTokenDisplay');
        const mermaidGraphContainer = document.getElementById('mermaidGraphContainer');
        const statusMessages = document.getElementById('statusMessages');

        const allDataDisplaySections = [
            sentenceSection, keySection, sentenceDisplaySection, verbalUnitsSection, 
            structuredDisplaySection, mermaidDisplaySection
        ];

        fileInput.addEventListener('change', handleFileSelect);
        sentenceSelector.addEventListener('change', handleSentenceSelection);

        function displayError(message) { statusMessages.innerHTML = `<p class="error">${message}</p>`; console.error(message); }
        function displayStatus(message) { statusMessages.innerHTML = `<p>${message}</p>`; console.log(message); }

        function clearPreviousData() {
            parsedSentences = []; parsedVerbalUnits = []; parsedTokens = [];
            sentenceSelector.innerHTML = '<option value="">-- Load a file --</option>';
            selectedSentenceDisplay.textContent = '';
            verbalUnitsDisplayUl.innerHTML = '';
            sentenceTextDisplay.innerHTML = '';
            structuredTokenDisplay.innerHTML = '';
            mermaidGraphContainer.innerHTML = ''; 
            mermaidGraphContainer.removeAttribute('data-processed');

            allDataDisplaySections.forEach(section => section.style.display = 'none');
            statusMessages.innerHTML = '';
        }

        function handleFileSelect(event) {
            clearPreviousData();
            const file = event.target.files[0];
            if (!file) { displayError('No file selected.'); return; }
            displayStatus(`Loading ${file.name}...`);
            const parser = new CEXParser();
            parser.loadFromFile(file)
                .then(p => {
                    displayStatus('CEX data loaded! Processing...');
                    const sentencesStr = p.getDelimitedData("sentences");
                    const verbalUnitsStr = p.getDelimitedData("verbal_units");
                    const tokensStr = p.getDelimitedData("tokens");

                    if (!sentencesStr || !verbalUnitsStr || !tokensStr) { displayError('Required data blocks missing.'); return; }

                    const sLines = sentencesStr.trim().split('\n');
                    parsedSentences = sLines.length > 1 ? sLines.slice(1).map(l => ({ id: l.split('|')[0], s: l.split('|')[1], c: l.split('|')[2] })).filter(s => s.id && s.id.trim()) : [];
                    const vuLines = verbalUnitsStr.trim().split('\n');
                    parsedVerbalUnits = vuLines.length > 1 ? vuLines.slice(1).map(l => { const ps = l.split('|'); return { vuid: ps[0], st: ps[1], sem: ps[2], depth: ps[3], sent: ps[4] }; }).filter(vu => vu.vuid && vu.vuid.trim() && vu.sent && vu.sent.trim()) : [];
                    const tLines = tokensStr.trim().split('\n');
                    parsedTokens = tLines.length > 1 ? tLines.slice(1).map(l => { const ps = l.split('|'); return { u: ps[0], ref: ps[1], tt: ps[2], txt: ps[3], vu: ps[4], n1: ps[5], n1r: (ps[6] || "").trim(), n2: ps[7], n2r: (ps[8] || "").trim() }; }).filter(t => t.u && t.u.trim() && t.vu && t.vu.trim()) : [];
                    
                    if (parsedVerbalUnits.length === 0) { displayError(`No valid VUs. ${vuLines.length <=1 && verbalUnitsStr.trim() ? 'Block empty/header.' : ''}`); return; }
                    if (parsedSentences.length === 0 && sLines.length > 1) displayStatus('Warning: Sentences block empty/header.');
                    
                    populateSentenceSelector();
                    sentenceSection.style.display = 'block'; // Show sentence selector
                    // Other sections shown upon sentence selection
                    displayStatus(`Processed ${file.name}. Select sentence.`);
                })
                .catch(e => { displayError(`File error: ${e.message}`); console.error('Err:', e); });
        }

        function populateSentenceSelector() {
            sentenceSelector.innerHTML = '<option value="">-- Select --</option>'; 
            const vuSents = new Set(parsedVerbalUnits.map(vu => vu.sent));
            const sIds = new Set(parsedSentences.map(s => s.id));
            const dispIds = [...sIds].filter(id => vuSents.has(id)).sort((a,b)=>{const nA=parseInt(a.match(/\d+$/)?.[0]||a),nB=parseInt(b.match(/\d+$/)?.[0]||b);return(!isNaN(nA)&&!isNaN(nB))?nA-nB:a.localeCompare(b);});
            if(dispIds.length===0){sentenceSelector.innerHTML='<option value="">-- No Sents w/VUs --</option>';displayStatus('Info: No sentences found with VUs.');return;}
            dispIds.forEach(id=>sentenceSelector.add(new Option(id,id)));
        }

        function escapeMermaidLabel(text) { return text ? text.replace(/"/g, '#quot;') : ""; }

        function _createTokenSpan(token, VUsInSent) {
            const span = document.createElement('span');
            span.className = 'token-span'; span.textContent = token.txt;
            const vu = VUsInSent.find(v => v.vuid === token.vu);
            if (vu && vu.dispClr) span.style.backgroundColor = vu.dispClr; else { span.style.backgroundColor = '#eee'; span.style.color = '#555'; }
            if (token.n1r === 'unit verb') span.classList.add('token-unit-verb');
            if (token.n1r === 'subject') span.classList.add('token-subject');
            if (token.n1r === 'direct object' || token.n1r === 'predicate') span.classList.add('token-direct-object-predicate');
            return span;
        }

        async function handleSentenceSelection(event) {
            const selSentId = event.target.value;
            // Clear content areas first
            verbalUnitsDisplayUl.innerHTML = ''; sentenceTextDisplay.innerHTML = ''; structuredTokenDisplay.innerHTML = '';
            mermaidGraphContainer.innerHTML = ''; mermaidGraphContainer.removeAttribute('data-processed');

            // Hide all specific data display sections, then show what's needed
            [keySection, sentenceDisplaySection, verbalUnitsSection, structuredDisplaySection, mermaidDisplaySection].forEach(s => s.style.display = 'none');
            
            if (!selSentId) { selectedSentenceDisplay.textContent = ''; return; }
            selectedSentenceDisplay.textContent = `Data for sentence: ${selSentId}`;
            
            // Show the key and always-visible sections once a sentence is selected
            keySection.style.display = 'block';
            sentenceDisplaySection.style.display = 'block';
            verbalUnitsSection.style.display = 'block';
            structuredDisplaySection.style.display = 'block'; // Outer div for <details>
            mermaidDisplaySection.style.display = 'block';   // Outer div for <details>

            let locClrIdx = 0; 
            const VUsInSent = parsedVerbalUnits.filter(vu => vu.sent === selSentId).map(vo => ({ ...vo, dispClr: PASTEL_COLORS[locClrIdx++ % PASTEL_COLORS.length] }));
            
            if (VUsInSent.length === 0) {
                const noVuMsg = '<em>No VUs, so no tokens.</em>';
                verbalUnitsDisplayUl.innerHTML = '<li>No VUs.</li>';
                sentenceTextDisplay.innerHTML = noVuMsg;
                structuredTokenDisplay.innerHTML = noVuMsg;
                mermaidGraphContainer.innerHTML = noVuMsg;
                // Key, continuous sentence, and VU list containers are already visible. 
                // The <details> containers for structured/mermaid are also visible but their content will show this message.
                return;
            }

            VUsInSent.forEach(vu => {
                const tc = parsedTokens.filter(t => t.vu === vu.vuid).length;
                const li = document.createElement('li'); const ss = document.createElement('span');
                ss.className = 'syntactic-type'; ss.style.backgroundColor = vu.dispClr; ss.textContent = vu.st;
                li.appendChild(ss); li.innerHTML += ` (${vu.sem || 'N/A'}) - Tokens: ${tc}`;
                verbalUnitsDisplayUl.appendChild(li);
            });

            const vuIdsInSent = new Set(VUsInSent.map(vu => vu.vuid));
            let sentToks = parsedTokens.filter(t => vuIdsInSent.has(t.vu)).sort((a,b)=>{const rA=parseInt(a.ref,10),rB=parseInt(b.ref,10);if(isNaN(rA)&&isNaN(rB))return 0;if(isNaN(rA))return 1;if(isNaN(rB))return -1;return rA-rB;});

            if (sentToks.length > 0) {
                sentToks.forEach(t => { sentenceTextDisplay.appendChild(_createTokenSpan(t, VUsInSent)); sentenceTextDisplay.appendChild(document.createTextNode(' ')); });
                if (sentenceTextDisplay.lastChild && sentenceTextDisplay.lastChild.nodeType === Node.TEXT_NODE) sentenceTextDisplay.removeChild(sentenceTextDisplay.lastChild);
                
                let curVUID = null, curLineDiv = null; const indentPx = 20;
                sentToks.forEach(t => {
                    if (t.vu !== curVUID) {
                        curVUID = t.vu; curLineDiv = document.createElement('div'); curLineDiv.className = 'structured-token-line';
                        const pVU = VUsInSent.find(v => v.vuid === curVUID);
                        if(pVU){const d=parseInt(pVU.depth,10)||1;curLineDiv.style.paddingLeft=`${Math.max(0,d-1)*indentPx}px`;}
                        structuredTokenDisplay.appendChild(curLineDiv);
                    }
                    if (curLineDiv) { if (curLineDiv.hasChildNodes()) curLineDiv.appendChild(document.createTextNode(' ')); curLineDiv.appendChild(_createTokenSpan(t, VUsInSent)); }
                });

                const mermaidDef = ['graph BT;']; const validNodeRefs = new Set(sentToks.map(t => t.ref));
                sentToks.forEach(t => mermaidDef.push(`${t.ref}["${escapeMermaidLabel(t.txt)}"];`));
                sentToks.forEach(t => {
                    if (t.n1 && validNodeRefs.has(t.n1) && t.n1r) mermaidDef.push(`${t.n1} -- "${escapeMermaidLabel(t.n1r)}" --> ${t.ref};`);
                    if (t.n2 && validNodeRefs.has(t.n2) && t.n2r) mermaidDef.push(`${t.n2} -- "${escapeMermaidLabel(t.n2r)}" --> ${t.ref};`);
                });
                const mermaidString = mermaidDef.join('\n');
                try {
                    const { svg, bindFunctions } = await mermaid.render('mermaid-graph-' + Date.now(), mermaidString);
                    mermaidGraphContainer.innerHTML = svg;
                    if (bindFunctions) bindFunctions(mermaidGraphContainer);
                } catch (e) {
                    mermaidGraphContainer.innerHTML = `<p class="error">Mermaid error: ${e.message}</p><pre>${mermaidString}</pre>`;
                    console.error("Mermaid err:", e, "\nDef:\n", mermaidString);
                }
            } else {
                const noTokenMsg = '<em>No tokens for VUs in this sentence.</em>';
                sentenceTextDisplay.innerHTML = noTokenMsg;
                structuredTokenDisplay.innerHTML = noTokenMsg;
                mermaidGraphContainer.innerHTML = noTokenMsg;
            }
        }
    </script>
</body>
</html>
```

Key Changes:

1.  **HTML Structure:**
    *   **New "Key" Section:** Added `div#keySection` with `<details open>` and static content.
    *   **Collapsible Sections:** The content of `div#structuredDisplaySection` and `div#mermaidDisplaySection` is now wrapped in `<details>` and `<summary>` tags. The original `<h2>`s are now inside the `<summary>`s.
    *   The `div#sentenceTextDisplay` (continuous text) and `div#verbalUnitsDisplay` are *not* wrapped in `<details>`, so their parent `div`s control their visibility, and they will always show their content once visible.
    *   I've added a class `details-content` to the divs that hold the actual content inside `<details>` (and also to `sentenceTextDisplay` for consistent padding).

2.  **CSS:**
    *   Added styling for `<details>`, `<summary>`, and `<h3>` within the key's summary.
    *   Removed default list markers from `<summary>`.
    *   The `.details-content` class is used for padding the content within `<details>`.
    *   The `verbalUnitsDisplay ul` has styling to look like a bordered box.

3.  **JavaScript:**
    *   **`allDataDisplaySections` Array:** Created an array to manage the main display `div`s more easily in `clearPreviousData`.
    *   **`keySection` Variable:** Added a reference to the new `div#keySection`.
    *   **`clearPreviousData()`:** Now iterates `allDataDisplaySections` to hide them.
    *   **`handleFileSelect()`:** Only shows `sentenceSection` after file load.
    *   **`handleSentenceSelection()`:**
        *   At the beginning, it hides all specific data display sections (key, continuous, VUs, structured, mermaid).
        *   If a sentence is selected (`selSentId` is true), it then explicitly shows the *container divs* for the key, continuous text, verbal units, structured layout, and Mermaid graph. The `<details>` elements within `structuredDisplaySection` and `mermaidDisplaySection` will then manage whether their *content* is expanded or collapsed by user interaction. The "Key" section's `<details>` is `open` by default.

This should give you the desired layout with collapsible sections for "Structured Layout" and "Syntax Graph," an always-open "Key" section (once data is loaded), and always-visible "Verbal Units" and "Continuous Sentence Text" sections.

### USER
Perfect. Let's make the "Key" section foldable, too.

### ASSISTANT
Okay, making the "Key" section foldable (and closed by default, for instance, or whatever default state you prefer) is straightforward. We just need to remove the `open` attribute from its `<details>` tag in the HTML.

Here's the modified `<div id="keySection">...</div>` block in the HTML. The rest of the file (CSS, other HTML, JavaScript) will remain the same as the previous version.

**Modified HTML for the Key Section:**

```html
        <!-- Key Section - Collapsible -->
        <div id="keySection" style="display: none;">
            <details> <!-- REMOVED 'open' attribute -->
                <summary><h3>Key</h3></summary>
                <div class="details-content">
                    <ul>
                        <li><strong>Boxes:</strong> verb forms (token with <code>node1relation</code> = "unit verb")</li>
                        <li><strong>Underscore:</strong> subject of verb (token with <code>node1relation</code> = "subject")</li>
                        <li><strong>Underscore + Overline:</strong> direct object or predicate (token with <code>node1relation</code> = "direct object" or "predicate")</li>
                    </ul>
                </div>
            </details>
        </div>
```

**Full HTML File (with only the Key section change highlighted):**

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Greek Syntax Annotations Viewer</title>
    <script src="https://cdn.jsdelivr.net/gh/neelsmith/cex-lib/cex.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.min.js"></script>
    <style>
        body {
            font-family: sans-serif;
            margin: 20px;
            background-color: #f4f4f4;
            color: #333;
        }
        .container {
            background-color: #fff;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 0 10px rgba(0,0,0,0.1);
            margin-bottom: 30px; 
        }
        h1, h2 { /* Base for main section titles */
            color: #555;
            margin-top: 25px; /* More space before main sections */
            margin-bottom: 10px;
        }
        h1:first-child, h2:first-child {
            margin-top: 0;
        }
        label {
            display: block;
            margin-top: 10px;
            margin-bottom: 5px;
            font-weight: bold;
        }
        select, input[type="file"] {
            padding: 8px;
            margin-bottom: 15px;
            border-radius: 4px;
            border: 1px solid #ccc;
            width: 100%;
            box-sizing: border-box;
        }
        #selectedSentenceDisplay {
            margin-top: 15px;
            padding: 10px;
            background-color: #e9e9e9;
            border-left: 5px solid #007bff;
            font-style: italic;
            margin-bottom: 20px;
        }

        /* Collapsible Section Styling */
        details {
            border: 1px solid #ddd;
            border-radius: 4px;
            margin-bottom: 15px;
            background-color: #fff; /* Give details a background for content */
        }
        details[open] {
            /* Optional: slightly more emphasis when open */
        }
        summary {
            padding: 10px 15px;
            background-color: #f9f9f9;
            border-bottom: 1px solid #ddd; /* Separator for summary */
            cursor: pointer;
            list-style: none; /* Remove default marker */
            font-weight: bold;
            color: #444;
        }
        summary::-webkit-details-marker { display: none; } /* Chrome/Safari */
        summary::marker { display: none; } /* Firefox */
        summary:hover { background-color: #f0f0f0; }
        
        details summary h2, details summary h3 {
            display: inline; /* Keep marker (if any) or custom arrow on same line */
            margin: 0;
            font-size: 1.2em; /* Default for h2 in summary */
            color: #555;
        }
        /* Key section specific header */
        #keySection details summary h3 {
            font-size: 1.0em; /* Smaller header for "Key" */
            font-weight: bold;
            color: #666;
        }
        .details-content {
            padding: 15px;
        }
        #keySection .details-content ul {
            padding-left: 20px;
            margin-top: 5px;
            margin-bottom: 5px;
        }
        #keySection .details-content li {
            margin-bottom: 3px;
        }


        #verbalUnitsDisplay ul {
            list-style-type: none;
            padding: 0;
            background-color: white; /* Ensure VU list has white BG */
            border: 1px solid #ddd;
            border-radius: 4px;
            padding:10px;
        }
        #verbalUnitsDisplay li {
            padding: 8px;
            border-bottom: 1px solid #eee;
            margin-bottom: 5px;
        }
        #verbalUnitsDisplay li:last-child {
            border-bottom: none;
        }
        .syntactic-type {
            padding: 2px 5px;
            border-radius: 3px;
            font-weight: bold;
            color: #000;
        }
        #sentenceTextDisplay, #structuredTokenDisplay, #mermaidGraphContainer {
            /* These are now inside .details-content, so direct background/padding might not be needed
               unless .details-content doesn't provide it */
        }
        #sentenceTextDisplay {
            line-height: 2.2; 
            word-spacing: 2px;
        }
        #structuredTokenDisplay {
            font-size: 1em; 
        }
        .structured-token-line {
            margin-bottom: 4px; 
            line-height: 1.8; 
        }
        .token-span {
            padding: 3px 5px; 
            margin-bottom: 5px; 
            display: inline-block; 
            border-radius: 3px;
            color: #000; 
            position: relative; 
        }
        .token-unit-verb { border: 1.5px solid #444; }
        .token-subject {
            text-decoration: underline;
            text-decoration-color: #333;
            text-decoration-thickness: 1.5px;
            text-underline-offset: 3px;
        }
        .token-direct-object-predicate {
            text-decoration: underline overline;
            text-decoration-color: #333;
            text-decoration-thickness: 1.5px;
            text-underline-offset: 3px;
        }
        #mermaidGraphContainer svg { 
            max-width: 100%;
            height: auto;
        }
        .error { color: red; font-weight: bold; }
    </style>
</head>
<body>
    <div class="container">
        <h1>Greek Syntax Data Loader</h1>
        <label for="fileInput">Choose a CEX file:</label>
        <input type="file" id="fileInput" accept=".cex">

        <div id="sentenceSection" style="display: none;">
            <label for="sentenceSelector">Select a Sentence:</label>
            <select id="sentenceSelector"></select>
            <div id="selectedSentenceDisplay"></div>
        </div>

        <!-- Key Section - Collapsible -->
        <div id="keySection" style="display: none;">
            <details> <!-- <<<<<<<<<<<<<<<<< 'open' attribute REMOVED HERE <<<<<<<<<<<<<<<<< -->
                <summary><h3>Key</h3></summary>
                <div class="details-content">
                    <ul>
                        <li><strong>Boxes:</strong> verb forms (token with <code>node1relation</code> = "unit verb")</li>
                        <li><strong>Underscore:</strong> subject of verb (token with <code>node1relation</code> = "subject")</li>
                        <li><strong>Underscore + Overline:</strong> direct object or predicate (token with <code>node1relation</code> = "direct object" or "predicate")</li>
                    </ul>
                </div>
            </details>
        </div>

        <!-- Sentence Text (Continuous) - Always Visible Content Area when data is loaded -->
        <div id="sentenceDisplaySection" style="display: none;">
            <h2>Sentence Text (Continuous):</h2>
            <div id="sentenceTextDisplay" class="details-content"> <!-- Re-using .details-content for padding -->
                <!-- Tokens will be rendered here -->
            </div>
        </div>

        <!-- Verbal Units Section - Always Visible Content Area when data is loaded -->
        <div id="verbalUnitsSection" style="display: none;">
            <h2>Verbal Units in Selected Sentence:</h2>
            <div id="verbalUnitsDisplay"><ul></ul></div>
        </div>

        <!-- Structured Layout - Collapsible -->
        <div id="structuredDisplaySection" style="display: none;">
            <details>
                <summary><h2>Sentence Text (Structured by Verbal Unit Depth)</h2></summary>
                <div id="structuredTokenDisplay" class="details-content">
                    <!-- Structured tokens will be rendered here -->
                </div>
            </details>
        </div>

        <!-- Mermaid Graph - Collapsible -->
        <div id="mermaidDisplaySection" style="display: none;">
            <details>
                <summary><h2>Syntax Graph (Mermaid)</h2></summary>
                <div id="mermaidGraphContainer" class="mermaid details-content">
                    <!-- Mermaid graph will be rendered here -->
                </div>
            </details>
        </div>
        
        <div id="statusMessages"></div>
    </div>

    <script>
        mermaid.initialize({ startOnLoad: false, securityLevel: 'loose' });

        let parsedSentences = [], parsedVerbalUnits = [], parsedTokens = [];
        const PASTEL_COLORS = ["#FFB3BA", "#FFDFBA", "#FFFFBA", "#BAFFC9", "#BAE1FF", "#E0BBE4", "#FFDAC1", "#B5EAD7", "#F9C7CF", "#C7CEEA"];

        const fileInput = document.getElementById('fileInput');
        const sentenceSelector = document.getElementById('sentenceSelector');
        const selectedSentenceDisplay = document.getElementById('selectedSentenceDisplay');
        const verbalUnitsDisplayUl = document.querySelector('#verbalUnitsDisplay ul');
        
        const sentenceSection = document.getElementById('sentenceSection');
        const keySection = document.getElementById('keySection'); 
        const sentenceDisplaySection = document.getElementById('sentenceDisplaySection');
        const verbalUnitsSection = document.getElementById('verbalUnitsSection');
        const structuredDisplaySection = document.getElementById('structuredDisplaySection');
        const mermaidDisplaySection = document.getElementById('mermaidDisplaySection');
        
        const sentenceTextDisplay = document.getElementById('sentenceTextDisplay');
        const structuredTokenDisplay = document.getElementById('structuredTokenDisplay');
        const mermaidGraphContainer = document.getElementById('mermaidGraphContainer');
        const statusMessages = document.getElementById('statusMessages');

        const allDataDisplaySections = [
            sentenceSection, keySection, sentenceDisplaySection, verbalUnitsSection, 
            structuredDisplaySection, mermaidDisplaySection
        ];

        fileInput.addEventListener('change', handleFileSelect);
        sentenceSelector.addEventListener('change', handleSentenceSelection);

        function displayError(message) { statusMessages.innerHTML = `<p class="error">${message}</p>`; console.error(message); }
        function displayStatus(message) { statusMessages.innerHTML = `<p>${message}</p>`; console.log(message); }

        function clearPreviousData() {
            parsedSentences = []; parsedVerbalUnits = []; parsedTokens = [];
            sentenceSelector.innerHTML = '<option value="">-- Load a file --</option>';
            selectedSentenceDisplay.textContent = '';
            verbalUnitsDisplayUl.innerHTML = '';
            sentenceTextDisplay.innerHTML = '';
            structuredTokenDisplay.innerHTML = '';
            mermaidGraphContainer.innerHTML = ''; 
            mermaidGraphContainer.removeAttribute('data-processed');

            allDataDisplaySections.forEach(section => section.style.display = 'none');
            statusMessages.innerHTML = '';
        }

        function handleFileSelect(event) {
            clearPreviousData();
            const file = event.target.files[0];
            if (!file) { displayError('No file selected.'); return; }
            displayStatus(`Loading ${file.name}...`);
            const parser = new CEXParser();
            parser.loadFromFile(file)
                .then(p => {
                    displayStatus('CEX data loaded! Processing...');
                    const sentencesStr = p.getDelimitedData("sentences");
                    const verbalUnitsStr = p.getDelimitedData("verbal_units");
                    const tokensStr = p.getDelimitedData("tokens");

                    if (!sentencesStr || !verbalUnitsStr || !tokensStr) { displayError('Required data blocks missing.'); return; }

                    const sLines = sentencesStr.trim().split('\n');
                    parsedSentences = sLines.length > 1 ? sLines.slice(1).map(l => ({ id: l.split('|')[0], s: l.split('|')[1], c: l.split('|')[2] })).filter(s => s.id && s.id.trim()) : [];
                    const vuLines = verbalUnitsStr.trim().split('\n');
                    parsedVerbalUnits = vuLines.length > 1 ? vuLines.slice(1).map(l => { const ps = l.split('|'); return { vuid: ps[0], st: ps[1], sem: ps[2], depth: ps[3], sent: ps[4] }; }).filter(vu => vu.vuid && vu.vuid.trim() && vu.sent && vu.sent.trim()) : [];
                    const tLines = tokensStr.trim().split('\n');
                    parsedTokens = tLines.length > 1 ? tLines.slice(1).map(l => { const ps = l.split('|'); return { u: ps[0], ref: ps[1], tt: ps[2], txt: ps[3], vu: ps[4], n1: ps[5], n1r: (ps[6] || "").trim(), n2: ps[7], n2r: (ps[8] || "").trim() }; }).filter(t => t.u && t.u.trim() && t.vu && t.vu.trim()) : [];
                    
                    if (parsedVerbalUnits.length === 0) { displayError(`No valid VUs. ${vuLines.length <=1 && verbalUnitsStr.trim() ? 'Block empty/header.' : ''}`); return; }
                    if (parsedSentences.length === 0 && sLines.length > 1) displayStatus('Warning: Sentences block empty/header.');
                    
                    populateSentenceSelector();
                    sentenceSection.style.display = 'block'; 
                    displayStatus(`Processed ${file.name}. Select sentence.`);
                })
                .catch(e => { displayError(`File error: ${e.message}`); console.error('Err:', e); });
        }

        function populateSentenceSelector() {
            sentenceSelector.innerHTML = '<option value="">-- Select --</option>'; 
            const vuSents = new Set(parsedVerbalUnits.map(vu => vu.sent));
            const sIds = new Set(parsedSentences.map(s => s.id));
            const dispIds = [...sIds].filter(id => vuSents.has(id)).sort((a,b)=>{const nA=parseInt(a.match(/\d+$/)?.[0]||a),nB=parseInt(b.match(/\d+$/)?.[0]||b);return(!isNaN(nA)&&!isNaN(nB))?nA-nB:a.localeCompare(b);});
            if(dispIds.length===0){sentenceSelector.innerHTML='<option value="">-- No Sents w/VUs --</option>';displayStatus('Info: No sentences found with VUs.');return;}
            dispIds.forEach(id=>sentenceSelector.add(new Option(id,id)));
        }

        function escapeMermaidLabel(text) { return text ? text.replace(/"/g, '#quot;') : ""; }

        function _createTokenSpan(token, VUsInSent) {
            const span = document.createElement('span');
            span.className = 'token-span'; span.textContent = token.txt;
            const vu = VUsInSent.find(v => v.vuid === token.vu);
            if (vu && vu.dispClr) span.style.backgroundColor = vu.dispClr; else { span.style.backgroundColor = '#eee'; span.style.color = '#555'; }
            if (token.n1r === 'unit verb') span.classList.add('token-unit-verb');
            if (token.n1r === 'subject') span.classList.add('token-subject');
            if (token.n1r === 'direct object' || token.n1r === 'predicate') span.classList.add('token-direct-object-predicate');
            return span;
        }

        async function handleSentenceSelection(event) {
            const selSentId = event.target.value;
            verbalUnitsDisplayUl.innerHTML = ''; sentenceTextDisplay.innerHTML = ''; structuredTokenDisplay.innerHTML = '';
            mermaidGraphContainer.innerHTML = ''; mermaidGraphContainer.removeAttribute('data-processed');

            [keySection, sentenceDisplaySection, verbalUnitsSection, structuredDisplaySection, mermaidDisplaySection].forEach(s => s.style.display = 'none');
            
            if (!selSentId) { selectedSentenceDisplay.textContent = ''; return; }
            selectedSentenceDisplay.textContent = `Data for sentence: ${selSentId}`;
            
            keySection.style.display = 'block';
            sentenceDisplaySection.style.display = 'block';
            verbalUnitsSection.style.display = 'block';
            structuredDisplaySection.style.display = 'block'; 
            mermaidDisplaySection.style.display = 'block';   

            let locClrIdx = 0; 
            const VUsInSent = parsedVerbalUnits.filter(vu => vu.sent === selSentId).map(vo => ({ ...vo, dispClr: PASTEL_COLORS[locClrIdx++ % PASTEL_COLORS.length] }));
            
            if (VUsInSent.length === 0) {
                const noVuMsg = '<em>No VUs, so no tokens.</em>';
                verbalUnitsDisplayUl.innerHTML = '<li>No VUs.</li>';
                sentenceTextDisplay.innerHTML = noVuMsg;
                structuredTokenDisplay.innerHTML = noVuMsg;
                mermaidGraphContainer.innerHTML = noVuMsg;
                return;
            }

            VUsInSent.forEach(vu => {
                const tc = parsedTokens.filter(t => t.vu === vu.vuid).length;
                const li = document.createElement('li'); const ss = document.createElement('span');
                ss.className = 'syntactic-type'; ss.style.backgroundColor = vu.dispClr; ss.textContent = vu.st;
                li.appendChild(ss); li.innerHTML += ` (${vu.sem || 'N/A'}) - Tokens: ${tc}`;
                verbalUnitsDisplayUl.appendChild(li);
            });

            const vuIdsInSent = new Set(VUsInSent.map(vu => vu.vuid));
            let sentToks = parsedTokens.filter(t => vuIdsInSent.has(t.vu)).sort((a,b)=>{const rA=parseInt(a.ref,10),rB=parseInt(b.ref,10);if(isNaN(rA)&&isNaN(rB))return 0;if(isNaN(rA))return 1;if(isNaN(rB))return -1;return rA-rB;});

            if (sentToks.length > 0) {
                sentToks.forEach(t => { sentenceTextDisplay.appendChild(_createTokenSpan(t, VUsInSent)); sentenceTextDisplay.appendChild(document.createTextNode(' ')); });
                if (sentenceTextDisplay.lastChild && sentenceTextDisplay.lastChild.nodeType === Node.TEXT_NODE) sentenceTextDisplay.removeChild(sentenceTextDisplay.lastChild);
                
                let curVUID = null, curLineDiv = null; const indentPx = 20;
                sentToks.forEach(t => {
                    if (t.vu !== curVUID) {
                        curVUID = t.vu; curLineDiv = document.createElement('div'); curLineDiv.className = 'structured-token-line';
                        const pVU = VUsInSent.find(v => v.vuid === curVUID);
                        if(pVU){const d=parseInt(pVU.depth,10)||1;curLineDiv.style.paddingLeft=`${Math.max(0,d-1)*indentPx}px`;}
                        structuredTokenDisplay.appendChild(curLineDiv);
                    }
                    if (curLineDiv) { if (curLineDiv.hasChildNodes()) curLineDiv.appendChild(document.createTextNode(' ')); curLineDiv.appendChild(_createTokenSpan(t, VUsInSent)); }
                });

                const mermaidDef = ['graph BT;']; const validNodeRefs = new Set(sentToks.map(t => t.ref));
                sentToks.forEach(t => mermaidDef.push(`${t.ref}["${escapeMermaidLabel(t.txt)}"];`));
                sentToks.forEach(t => {
                    if (t.n1 && validNodeRefs.has(t.n1) && t.n1r) mermaidDef.push(`${t.n1} -- "${escapeMermaidLabel(t.n1r)}" --> ${t.ref};`);
                    if (t.n2 && validNodeRefs.has(t.n2) && t.n2r) mermaidDef.push(`${t.n2} -- "${escapeMermaidLabel(t.n2r)}" --> ${t.ref};`);
                });
                const mermaidString = mermaidDef.join('\n');
                try {
                    const { svg, bindFunctions } = await mermaid.render('mermaid-graph-' + Date.now(), mermaidString);
                    mermaidGraphContainer.innerHTML = svg;
                    if (bindFunctions) bindFunctions(mermaidGraphContainer);
                } catch (e) {
                    mermaidGraphContainer.innerHTML = `<p class="error">Mermaid error: ${e.message}</p><pre>${mermaidString}</pre>`;
                    console.error("Mermaid err:", e, "\nDef:\n", mermaidString);
                }
            } else {
                const noTokenMsg = '<em>No tokens for VUs in this sentence.</em>';
                sentenceTextDisplay.innerHTML = noTokenMsg;
                structuredTokenDisplay.innerHTML = noTokenMsg;
                mermaidGraphContainer.innerHTML = noTokenMsg;
            }
        }
    </script>
</body>
</html>
```

The only change made was removing the `open` attribute from the `<details>` tag within `div#keySection`. Now, the "Key" section will also be collapsed by default and the user can click its summary to expand it.

### USER
Great. Now let's change the title element of the page and the top level header from "Greek Syntax Data Loader" to "Greek Syntax Viewer".

### ASSISTANT
Okay, that's a straightforward change. We'll update the `<title>` element in the `<head>` and the `<h1>` element in the `<body>`.

Here's the relevant parts of the HTML that will be changed:

**In the `<head>` section:**
Old:
```html
    <title>Greek Syntax Annotations Viewer</title>
```
New:
```html
    <title>Greek Syntax Viewer</title>
```
*(Wait, I see the previous title was already "Greek Syntax Annotations Viewer". The request is to change it from "Greek Syntax Data Loader" to "Greek Syntax Viewer". Let me correct my understanding and make sure the `h1` and `title` match the new request.)*

Okay, to be precise, the previous request produced:
`<title>Greek Syntax Annotations Viewer</title>`
and
`<h1>Greek Syntax Data Loader</h1>`

The new request is to change *both* of these to "Greek Syntax Viewer".

**Corrected Changes:**

**In the `<head>` section:**
Old:
```html
    <title>Greek Syntax Annotations Viewer</title>
```
New:
```html
    <title>Greek Syntax Viewer</title>
```

**In the `<body>` section:**
Old:
```html
        <h1>Greek Syntax Data Loader</h1>
```
New:
```html
        <h1>Greek Syntax Viewer</h1>
```

Here's the full HTML file with these two changes:

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Greek Syntax Viewer</title> <!-- CHANGED HERE -->
    <script src="https://cdn.jsdelivr.net/gh/neelsmith/cex-lib/cex.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.min.js"></script>
    <style>
        body {
            font-family: sans-serif;
            margin: 20px;
            background-color: #f4f4f4;
            color: #333;
        }
        .container {
            background-color: #fff;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 0 10px rgba(0,0,0,0.1);
            margin-bottom: 30px; 
        }
        h1, h2 { /* Base for main section titles */
            color: #555;
            margin-top: 25px; /* More space before main sections */
            margin-bottom: 10px;
        }
        h1:first-child, h2:first-child {
            margin-top: 0;
        }
        label {
            display: block;
            margin-top: 10px;
            margin-bottom: 5px;
            font-weight: bold;
        }
        select, input[type="file"] {
            padding: 8px;
            margin-bottom: 15px;
            border-radius: 4px;
            border: 1px solid #ccc;
            width: 100%;
            box-sizing: border-box;
        }
        #selectedSentenceDisplay {
            margin-top: 15px;
            padding: 10px;
            background-color: #e9e9e9;
            border-left: 5px solid #007bff;
            font-style: italic;
            margin-bottom: 20px;
        }

        /* Collapsible Section Styling */
        details {
            border: 1px solid #ddd;
            border-radius: 4px;
            margin-bottom: 15px;
            background-color: #fff; /* Give details a background for content */
        }
        details[open] {
            /* Optional: slightly more emphasis when open */
        }
        summary {
            padding: 10px 15px;
            background-color: #f9f9f9;
            border-bottom: 1px solid #ddd; /* Separator for summary */
            cursor: pointer;
            list-style: none; /* Remove default marker */
            font-weight: bold;
            color: #444;
        }
        summary::-webkit-details-marker { display: none; } /* Chrome/Safari */
        summary::marker { display: none; } /* Firefox */
        summary:hover { background-color: #f0f0f0; }
        
        details summary h2, details summary h3 {
            display: inline; /* Keep marker (if any) or custom arrow on same line */
            margin: 0;
            font-size: 1.2em; /* Default for h2 in summary */
            color: #555;
        }
        /* Key section specific header */
        #keySection details summary h3 {
            font-size: 1.0em; /* Smaller header for "Key" */
            font-weight: bold;
            color: #666;
        }
        .details-content {
            padding: 15px;
        }
        #keySection .details-content ul {
            padding-left: 20px;
            margin-top: 5px;
            margin-bottom: 5px;
        }
        #keySection .details-content li {
            margin-bottom: 3px;
        }


        #verbalUnitsDisplay ul {
            list-style-type: none;
            padding: 0;
            background-color: white; /* Ensure VU list has white BG */
            border: 1px solid #ddd;
            border-radius: 4px;
            padding:10px;
        }
        #verbalUnitsDisplay li {
            padding: 8px;
            border-bottom: 1px solid #eee;
            margin-bottom: 5px;
        }
        #verbalUnitsDisplay li:last-child {
            border-bottom: none;
        }
        .syntactic-type {
            padding: 2px 5px;
            border-radius: 3px;
            font-weight: bold;
            color: #000;
        }
        #sentenceTextDisplay, #structuredTokenDisplay, #mermaidGraphContainer {
            /* These are now inside .details-content, so direct background/padding might not be needed
               unless .details-content doesn't provide it */
        }
        #sentenceTextDisplay {
            line-height: 2.2; 
            word-spacing: 2px;
        }
        #structuredTokenDisplay {
            font-size: 1em; 
        }
        .structured-token-line {
            margin-bottom: 4px; 
            line-height: 1.8; 
        }
        .token-span {
            padding: 3px 5px; 
            margin-bottom: 5px; 
            display: inline-block; 
            border-radius: 3px;
            color: #000; 
            position: relative; 
        }
        .token-unit-verb { border: 1.5px solid #444; }
        .token-subject {
            text-decoration: underline;
            text-decoration-color: #333;
            text-decoration-thickness: 1.5px;
            text-underline-offset: 3px;
        }
        .token-direct-object-predicate {
            text-decoration: underline overline;
            text-decoration-color: #333;
            text-decoration-thickness: 1.5px;
            text-underline-offset: 3px;
        }
        #mermaidGraphContainer svg { 
            max-width: 100%;
            height: auto;
        }
        .error { color: red; font-weight: bold; }
    </style>
</head>
<body>
    <div class="container">
        <h1>Greek Syntax Viewer</h1> <!-- CHANGED HERE -->
        <label for="fileInput">Choose a CEX file:</label>
        <input type="file" id="fileInput" accept=".cex">

        <div id="sentenceSection" style="display: none;">
            <label for="sentenceSelector">Select a Sentence:</label>
            <select id="sentenceSelector"></select>
            <div id="selectedSentenceDisplay"></div>
        </div>

        <!-- Key Section - Collapsible -->
        <div id="keySection" style="display: none;">
            <details> 
                <summary><h3>Key</h3></summary>
                <div class="details-content">
                    <ul>
                        <li><strong>Boxes:</strong> verb forms (token with <code>node1relation</code> = "unit verb")</li>
                        <li><strong>Underscore:</strong> subject of verb (token with <code>node1relation</code> = "subject")</li>
                        <li><strong>Underscore + Overline:</strong> direct object or predicate (token with <code>node1relation</code> = "direct object" or "predicate")</li>
                    </ul>
                </div>
            </details>
        </div>

        <!-- Sentence Text (Continuous) - Always Visible Content Area when data is loaded -->
        <div id="sentenceDisplaySection" style="display: none;">
            <h2>Sentence Text (Continuous):</h2>
            <div id="sentenceTextDisplay" class="details-content"> 
                <!-- Tokens will be rendered here -->
            </div>
        </div>

        <!-- Verbal Units Section - Always Visible Content Area when data is loaded -->
        <div id="verbalUnitsSection" style="display: none;">
            <h2>Verbal Units in Selected Sentence:</h2>
            <div id="verbalUnitsDisplay"><ul></ul></div>
        </div>

        <!-- Structured Layout - Collapsible -->
        <div id="structuredDisplaySection" style="display: none;">
            <details>
                <summary><h2>Sentence Text (Structured by Verbal Unit Depth)</h2></summary>
                <div id="structuredTokenDisplay" class="details-content">
                    <!-- Structured tokens will be rendered here -->
                </div>
            </details>
        </div>

        <!-- Mermaid Graph - Collapsible -->
        <div id="mermaidDisplaySection" style="display: none;">
            <details>
                <summary><h2>Syntax Graph (Mermaid)</h2></summary>
                <div id="mermaidGraphContainer" class="mermaid details-content">
                    <!-- Mermaid graph will be rendered here -->
                </div>
            </details>
        </div>
        
        <div id="statusMessages"></div>
    </div>

    <script>
        mermaid.initialize({ startOnLoad: false, securityLevel: 'loose' });

        let parsedSentences = [], parsedVerbalUnits = [], parsedTokens = [];
        const PASTEL_COLORS = ["#FFB3BA", "#FFDFBA", "#FFFFBA", "#BAFFC9", "#BAE1FF", "#E0BBE4", "#FFDAC1", "#B5EAD7", "#F9C7CF", "#C7CEEA"];

        const fileInput = document.getElementById('fileInput');
        const sentenceSelector = document.getElementById('sentenceSelector');
        const selectedSentenceDisplay = document.getElementById('selectedSentenceDisplay');
        const verbalUnitsDisplayUl = document.querySelector('#verbalUnitsDisplay ul');
        
        const sentenceSection = document.getElementById('sentenceSection');
        const keySection = document.getElementById('keySection'); 
        const sentenceDisplaySection = document.getElementById('sentenceDisplaySection');
        const verbalUnitsSection = document.getElementById('verbalUnitsSection');
        const structuredDisplaySection = document.getElementById('structuredDisplaySection');
        const mermaidDisplaySection = document.getElementById('mermaidDisplaySection');
        
        const sentenceTextDisplay = document.getElementById('sentenceTextDisplay');
        const structuredTokenDisplay = document.getElementById('structuredTokenDisplay');
        const mermaidGraphContainer = document.getElementById('mermaidGraphContainer');
        const statusMessages = document.getElementById('statusMessages');

        const allDataDisplaySections = [
            sentenceSection, keySection, sentenceDisplaySection, verbalUnitsSection, 
            structuredDisplaySection, mermaidDisplaySection
        ];

        fileInput.addEventListener('change', handleFileSelect);
        sentenceSelector.addEventListener('change', handleSentenceSelection);

        function displayError(message) { statusMessages.innerHTML = `<p class="error">${message}</p>`; console.error(message); }
        function displayStatus(message) { statusMessages.innerHTML = `<p>${message}</p>`; console.log(message); }

        function clearPreviousData() {
            parsedSentences = []; parsedVerbalUnits = []; parsedTokens = [];
            sentenceSelector.innerHTML = '<option value="">-- Load a file --</option>';
            selectedSentenceDisplay.textContent = '';
            verbalUnitsDisplayUl.innerHTML = '';
            sentenceTextDisplay.innerHTML = '';
            structuredTokenDisplay.innerHTML = '';
            mermaidGraphContainer.innerHTML = ''; 
            mermaidGraphContainer.removeAttribute('data-processed');

            allDataDisplaySections.forEach(section => section.style.display = 'none');
            statusMessages.innerHTML = '';
        }

        function handleFileSelect(event) {
            clearPreviousData();
            const file = event.target.files[0];
            if (!file) { displayError('No file selected.'); return; }
            displayStatus(`Loading ${file.name}...`);
            const parser = new CEXParser();
            parser.loadFromFile(file)
                .then(p => {
                    displayStatus('CEX data loaded! Processing...');
                    const sentencesStr = p.getDelimitedData("sentences");
                    const verbalUnitsStr = p.getDelimitedData("verbal_units");
                    const tokensStr = p.getDelimitedData("tokens");

                    if (!sentencesStr || !verbalUnitsStr || !tokensStr) { displayError('Required data blocks missing.'); return; }

                    const sLines = sentencesStr.trim().split('\n');
                    parsedSentences = sLines.length > 1 ? sLines.slice(1).map(l => ({ id: l.split('|')[0], s: l.split('|')[1], c: l.split('|')[2] })).filter(s => s.id && s.id.trim()) : [];
                    const vuLines = verbalUnitsStr.trim().split('\n');
                    parsedVerbalUnits = vuLines.length > 1 ? vuLines.slice(1).map(l => { const ps = l.split('|'); return { vuid: ps[0], st: ps[1], sem: ps[2], depth: ps[3], sent: ps[4] }; }).filter(vu => vu.vuid && vu.vuid.trim() && vu.sent && vu.sent.trim()) : [];
                    const tLines = tokensStr.trim().split('\n');
                    parsedTokens = tLines.length > 1 ? tLines.slice(1).map(l => { const ps = l.split('|'); return { u: ps[0], ref: ps[1], tt: ps[2], txt: ps[3], vu: ps[4], n1: ps[5], n1r: (ps[6] || "").trim(), n2: ps[7], n2r: (ps[8] || "").trim() }; }).filter(t => t.u && t.u.trim() && t.vu && t.vu.trim()) : [];
                    
                    if (parsedVerbalUnits.length === 0) { displayError(`No valid VUs. ${vuLines.length <=1 && verbalUnitsStr.trim() ? 'Block empty/header.' : ''}`); return; }
                    if (parsedSentences.length === 0 && sLines.length > 1) displayStatus('Warning: Sentences block empty/header.');
                    
                    populateSentenceSelector();
                    sentenceSection.style.display = 'block'; 
                    displayStatus(`Processed ${file.name}. Select sentence.`);
                })
                .catch(e => { displayError(`File error: ${e.message}`); console.error('Err:', e); });
        }

        function populateSentenceSelector() {
            sentenceSelector.innerHTML = '<option value="">-- Select --</option>'; 
            const vuSents = new Set(parsedVerbalUnits.map(vu => vu.sent));
            const sIds = new Set(parsedSentences.map(s => s.id));
            const dispIds = [...sIds].filter(id => vuSents.has(id)).sort((a,b)=>{const nA=parseInt(a.match(/\d+$/)?.[0]||a),nB=parseInt(b.match(/\d+$/)?.[0]||b);return(!isNaN(nA)&&!isNaN(nB))?nA-nB:a.localeCompare(b);});
            if(dispIds.length===0){sentenceSelector.innerHTML='<option value="">-- No Sents w/VUs --</option>';displayStatus('Info: No sentences found with VUs.');return;}
            dispIds.forEach(id=>sentenceSelector.add(new Option(id,id)));
        }

        function escapeMermaidLabel(text) { return text ? text.replace(/"/g, '#quot;') : ""; }

        function _createTokenSpan(token, VUsInSent) {
            const span = document.createElement('span');
            span.className = 'token-span'; span.textContent = token.txt;
            const vu = VUsInSent.find(v => v.vuid === token.vu);
            if (vu && vu.dispClr) span.style.backgroundColor = vu.dispClr; else { span.style.backgroundColor = '#eee'; span.style.color = '#555'; }
            if (token.n1r === 'unit verb') span.classList.add('token-unit-verb');
            if (token.n1r === 'subject') span.classList.add('token-subject');
            if (token.n1r === 'direct object' || token.n1r === 'predicate') span.classList.add('token-direct-object-predicate');
            return span;
        }

        async function handleSentenceSelection(event) {
            const selSentId = event.target.value;
            verbalUnitsDisplayUl.innerHTML = ''; sentenceTextDisplay.innerHTML = ''; structuredTokenDisplay.innerHTML = '';
            mermaidGraphContainer.innerHTML = ''; mermaidGraphContainer.removeAttribute('data-processed');

            [keySection, sentenceDisplaySection, verbalUnitsSection, structuredDisplaySection, mermaidDisplaySection].forEach(s => s.style.display = 'none');
            
            if (!selSentId) { selectedSentenceDisplay.textContent = ''; return; }
            selectedSentenceDisplay.textContent = `Data for sentence: ${selSentId}`;
            
            keySection.style.display = 'block';
            sentenceDisplaySection.style.display = 'block';
            verbalUnitsSection.style.display = 'block';
            structuredDisplaySection.style.display = 'block'; 
            mermaidDisplaySection.style.display = 'block';   

            let locClrIdx = 0; 
            const VUsInSent = parsedVerbalUnits.filter(vu => vu.sent === selSentId).map(vo => ({ ...vo, dispClr: PASTEL_COLORS[locClrIdx++ % PASTEL_COLORS.length] }));
            
            if (VUsInSent.length === 0) {
                const noVuMsg = '<em>No VUs, so no tokens.</em>';
                verbalUnitsDisplayUl.innerHTML = '<li>No VUs.</li>';
                sentenceTextDisplay.innerHTML = noVuMsg;
                structuredTokenDisplay.innerHTML = noVuMsg;
                mermaidGraphContainer.innerHTML = noVuMsg;
                return;
            }

            VUsInSent.forEach(vu => {
                const tc = parsedTokens.filter(t => t.vu === vu.vuid).length;
                const li = document.createElement('li'); const ss = document.createElement('span');
                ss.className = 'syntactic-type'; ss.style.backgroundColor = vu.dispClr; ss.textContent = vu.st;
                li.appendChild(ss); li.innerHTML += ` (${vu.sem || 'N/A'}) - Tokens: ${tc}`;
                verbalUnitsDisplayUl.appendChild(li);
            });

            const vuIdsInSent = new Set(VUsInSent.map(vu => vu.vuid));
            let sentToks = parsedTokens.filter(t => vuIdsInSent.has(t.vu)).sort((a,b)=>{const rA=parseInt(a.ref,10),rB=parseInt(b.ref,10);if(isNaN(rA)&&isNaN(rB))return 0;if(isNaN(rA))return 1;if(isNaN(rB))return -1;return rA-rB;});

            if (sentToks.length > 0) {
                sentToks.forEach(t => { sentenceTextDisplay.appendChild(_createTokenSpan(t, VUsInSent)); sentenceTextDisplay.appendChild(document.createTextNode(' ')); });
                if (sentenceTextDisplay.lastChild && sentenceTextDisplay.lastChild.nodeType === Node.TEXT_NODE) sentenceTextDisplay.removeChild(sentenceTextDisplay.lastChild);
                
                let curVUID = null, curLineDiv = null; const indentPx = 20;
                sentToks.forEach(t => {
                    if (t.vu !== curVUID) {
                        curVUID = t.vu; curLineDiv = document.createElement('div'); curLineDiv.className = 'structured-token-line';
                        const pVU = VUsInSent.find(v => v.vuid === curVUID);
                        if(pVU){const d=parseInt(pVU.depth,10)||1;curLineDiv.style.paddingLeft=`${Math.max(0,d-1)*indentPx}px`;}
                        structuredTokenDisplay.appendChild(curLineDiv);
                    }
                    if (curLineDiv) { if (curLineDiv.hasChildNodes()) curLineDiv.appendChild(document.createTextNode(' ')); curLineDiv.appendChild(_createTokenSpan(t, VUsInSent)); }
                });

                const mermaidDef = ['graph BT;']; const validNodeRefs = new Set(sentToks.map(t => t.ref));
                sentToks.forEach(t => mermaidDef.push(`${t.ref}["${escapeMermaidLabel(t.txt)}"];`));
                sentToks.forEach(t => {
                    if (t.n1 && validNodeRefs.has(t.n1) && t.n1r) mermaidDef.push(`${t.n1} -- "${escapeMermaidLabel(t.n1r)}" --> ${t.ref};`);
                    if (t.n2 && validNodeRefs.has(t.n2) && t.n2r) mermaidDef.push(`${t.n2} -- "${escapeMermaidLabel(t.n2r)}" --> ${t.ref};`);
                });
                const mermaidString = mermaidDef.join('\n');
                try {
                    const { svg, bindFunctions } = await mermaid.render('mermaid-graph-' + Date.now(), mermaidString);
                    mermaidGraphContainer.innerHTML = svg;
                    if (bindFunctions) bindFunctions(mermaidGraphContainer);
                } catch (e) {
                    mermaidGraphContainer.innerHTML = `<p class="error">Mermaid error: ${e.message}</p><pre>${mermaidString}</pre>`;
                    console.error("Mermaid err:", e, "\nDef:\n", mermaidString);
                }
            } else {
                const noTokenMsg = '<em>No tokens for VUs in this sentence.</em>';
                sentenceTextDisplay.innerHTML = noTokenMsg;
                structuredTokenDisplay.innerHTML = noTokenMsg;
                mermaidGraphContainer.innerHTML = noTokenMsg;
            }
        }
    </script>
</body>
</html>
```

The app's title in the browser tab and the main heading on the page are now both "Greek Syntax Viewer".